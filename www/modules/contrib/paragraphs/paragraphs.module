<?php

/**
 * @file
 * Paragraphs hooks and common functions.
 *
 * Paragraphs allows you to embed multiple entity bundles in field.
 */

define('PARAGRAPHS_RECURSION_LIMIT', 20);
define('PARAGRAPHS_DEFAULT_TITLE', 'Paragraph');
define('PARAGRAPHS_DEFAULT_TITLE_MULTIPLE', 'Paragraphs');
define('PARAGRAPHS_DEFAULT_EDIT_MODE', 'open');
define('PARAGRAPHS_DEFAULT_EDIT_MODE_OVERRIDE', 1);
define('PARAGRAPHS_DEFAULT_ADD_MODE', 'select');
define('PARAGRAPHS_DEFAULT_MODAL_ADMIN', FALSE);

// Modules should return this value from hook_paragraphs_item_access() to allow
// access to a paragraphs item.
define('PARAGRAPHS_ITEM_ACCESS_ALLOW', 'allow');

// Modules should return this value from hook_paragraphs_item_access() to deny
// access to a paragraphs item.
define('PARAGRAPHS_ITEM_ACCESS_DENY', 'deny');

// Modules should return this value from hook_paragraphs_item_access() to not
// affect paragraphs item access.
define('PARAGRAPHS_ITEM_ACCESS_IGNORE', NULL);


// Separate some Field API parts in different files.
require_once dirname(__FILE__) . '/paragraphs.field_formatter.inc';
require_once dirname(__FILE__) . '/paragraphs.field_widget.inc';
require_once dirname(__FILE__) . '/paragraphs.node_clone.inc';

/**
 * Loads a paragraphs item.
 *
 * @param int $item_id
 *   The paragraphs item ID.
 * @param bool $reset
 *   Should we reset the entity cache?
 *
 * @return ParagraphsItemEntity
 *   The paragraphs item entity or FALSE.
 */
function paragraphs_item_load($item_id, $reset = FALSE) {
  $result = paragraphs_item_load_multiple(array($item_id), array(), $reset);
  return $result ? reset($result) : FALSE;
}

/**
 * Loads a paragraphs revision.
 *
 * @param int $revision_id
 *   The paragraphs revision ID.
 *
 * @return ParagraphsItemEntity
 *   The paragraphs item entity or FALSE.
 */
function paragraphs_item_revision_load($revision_id) {
  return entity_plus_revision_load('paragraphs_item', $revision_id);
}

/**
 * Loads paragraphs items.
 *
 * @param array $ids
 *   An array of paragraphs item IDs or FALSE to load all.
 * @param array|bool $conditions
 *   Should we reset the entity cache?
 * @param bool $reset
 *   Should we reset the entity cache?
 *
 * @return ParagraphsItemEntity[]
 *   An array of paragraphs item entities.
 */
function paragraphs_item_load_multiple(array $ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load_multiple('paragraphs_item', $ids, $conditions, $reset);
}

/**
 * Implements hook_config_info().
 */
function paragraphs_config_info() {
  return array(
    'paragraphs.type' => array(
      'name_key' => 'bundle',
      'label_key' => 'name',
      'group' => t('Paragraph types'),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function paragraphs_entity_info() {
  $return['paragraphs_item'] = array(
    'label' => t('Paragraphs item'),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'entity class' => 'ParagraphsItemEntity',
    'controller class' => 'ParagraphsItemEntityController',
    'base table' => 'paragraphs_item',
    'revision table' => 'paragraphs_item_revision',
    'fieldable' => TRUE,
    // For integration with Redirect module.
    // @see http://drupal.org/node/1263884
    'redirect' => FALSE,
    'entity keys' => array(
      'id' => 'item_id',
      'label' => 'label',
      'revision' => 'revision_id',
      'bundle' => 'bundle',
      'field_name' => 'field_name',
      'language' => 'langcode',
    ),
    'module' => 'paragraphs',
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
        'custom settings' => FALSE,
      ),
      'paragraphs_editor_preview' => array(
        'label' => t('Paragraphs Editor Preview'),
        'custom settings' => TRUE,
      ),
    ),
    'bundle keys' => array(
      'bundle' => 'bundle',
    ),
    'access callback' => 'paragraphs_item_access',
    'metadata controller class' => 'ParagraphsItemMetadataController',
  );

  $bundles = paragraphs_bundle_load();

  // Add info about the bundles. We do not use field_info_fields() but directly
  // use field_read_fields() as field_info_fields() requires built entity info
  // to work.
  foreach ($bundles as $machine_name => $bundle) {
    $return['paragraphs_item']['bundles'][$bundle->bundle] = array(
      'label' => $bundle->name,
      'admin' => array(
        'path' => 'admin/structure/paragraphs/%paragraphs_bundle',
        'real path' => 'admin/structure/paragraphs/' . strtr($machine_name, array('_' => '-')),
        'bundle argument' => 3,
        'access arguments' => array('administer paragraphs bundles'),
      ),
    );
  }

  $return['paragraphs_item']['field cache'] = FALSE;
  $return['paragraphs_item']['entity cache'] = TRUE;

  return $return;
}

/**
 * Access check for Paragraphs items.
 *
 * Most of the time the access callback is on the host entity.
 * In some cases you want specific access checks on paragraphs.
 * You can do this by implementing hook_paragraphs_item_access().
 *
 * @return bool
 *   Whether the user has access to a Paragraphs item.
 */
function paragraphs_item_access($op, $entity, $account = NULL) {
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  $permissions = &backdrop_static(__FUNCTION__, array());

  // If the $op was not one of the supported ones, we return access denied.
  if (!in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    return FALSE;
  }
  // If $op view and Paragraphs item not published, we return access denied.
  if ($op == 'view' && !$entity->status) {
    return FALSE;
  }

  // When we have no entity, create a generic cid.
  if (empty($entity) || !is_object($entity)) {
    $cid = 'all_entities:' . $op;
  }
  // When OP is create, or the entity is new, the bundle is the cache key.
  elseif ($op == 'create' || (isset($entity->is_new) && $entity->is_new)) {
    $cid = $entity->bundle;
  }
  // Else our cid is entity specific.
  else {
    $cid = $entity->item_id . '_' . $entity->revision_id;
  }

  // If we've already checked access for this bundle, user and op, return from
  // cache. Otherwise, we are optimistic and consider that the user can
  // view / update / delete or create a paragraph.
  if (isset($permissions[$account->uid][$cid][$op])) {
    return $permissions[$account->uid][$cid][$op];
  }

  // We grant access to the paragraph item if both of these conditions are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  // If no module specified either allow or deny, we always allow.
  $access = module_invoke_all('paragraphs_item_access', $entity, $op, $account);
  if (in_array(PARAGRAPHS_ITEM_ACCESS_DENY, $access, TRUE)) {
    $user_access_permission = FALSE;
  }
  elseif (in_array(PARAGRAPHS_ITEM_ACCESS_ALLOW, $access, TRUE)) {
    $user_access_permission = TRUE;
  }
  else {
    // Deny access by default.
    $user_access_permission = FALSE;
  }

  // Store the result of the permission in our matrix.
  $permissions[$account->uid][$cid][$op] = $user_access_permission;

  return $permissions[$account->uid][$cid][$op];
}

/**
 * Implements hook_paragraphs_item_access().
 */
function paragraphs_paragraphs_item_access(ParagraphsItemEntity $entity, $op, $account) {
  $permissions = &backdrop_static(__FUNCTION__, array());
  $parent_permissions = &backdrop_static(__FUNCTION__  . '_parents', array());

  if (!in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    // If there was no bundle to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return PARAGRAPHS_ITEM_ACCESS_IGNORE;
  }

  $check_parent_op = $op;

  // Update/Delete/Create access requires update access on the parent.
  if (in_array($op, array('update', 'delete', 'create'), TRUE)) {
    $check_parent_op = 'update';
  }

  // If $op view and Paragraphs item not published, we return access denied.
  if ($op == 'view' && !$entity->status) {
    return FALSE;
  }

  // When we have no entity, create a generic cid.
  if (empty($entity)) {
    $cid = 'all_entities:' . $op;
  }
  // When OP is create, or the entity is new, the bundle is the cache key.
  elseif ($op == 'create' || (isset($entity->is_new) && $entity->is_new)) {
    $cid = $entity->bundle;
  }
  // Else our cid is entity specific.
  else {
    $cid = $entity->item_id . '_' . $entity->revision_id;
  }

  // Check if we cached permission check.
  if (isset($permissions[$account->uid][$cid][$op])) {
    return $permissions[$account->uid][$cid][$op];
  }

  if (empty($entity)) {
    // Ignore access when we don't have a host entity.
    $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_IGNORE;
  }
  elseif ($host_entity = $entity->hostEntity()) {
    $host_entity_info = entity_get_info($entity->hostEntityType());
    $host_id_key = $host_entity_info['entity keys']['id'];

    $parent_cid = $entity->hostEntityType() . '_' . implode('_', entity_extract_ids($entity->hostEntityType(), $host_entity));

    // Check if we have an ID key set. If not then the parent entity is new and
    // we check for create access.
    if (!isset($host_entity->{$host_id_key}) || empty($host_entity->{$host_id_key})) {
      $check_parent_op = 'create';
      $host_entity->is_new = TRUE;
    }

    if (isset($parent_permissions[$account->uid][$parent_cid][$check_parent_op])) {
      return $parent_permissions[$account->uid][$parent_cid][$check_parent_op];
    }

    // We need to use node_access over node's entity_access permission check
    // because entity_access will fallback to checking revision permissions when
    // trying to update paragraph items in a node revision.
    if ($entity->hostEntityType() == 'node') {
      // We assume that any node without a nid is being created and check
      // permissions against the node bundle.
      if (!isset($host_entity->nid) && node_access($check_parent_op, $entity->hostEntityBundle())) {
        $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_ALLOW;
      }
      elseif (isset($host_entity->nid) && node_access($check_parent_op, $host_entity)) {
        $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_ALLOW;
      }
      else {
        $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_DENY;
      }
    }
    else {
      if (entity_access($check_parent_op, $entity->hostEntityType(), $host_entity)) {
        $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_ALLOW;
        $parent_permissions[$account->uid][$parent_cid][$check_parent_op] = PARAGRAPHS_ITEM_ACCESS_ALLOW;
      }
      else {
        // Deny access as parent entity access failed.
        $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_DENY;
        $parent_permissions[$account->uid][$parent_cid][$check_parent_op] = PARAGRAPHS_ITEM_ACCESS_DENY;
      }
    }
  }
  else {
    // Ignore access when we don't have a host entity.
    $permissions[$account->uid][$cid][$op] = PARAGRAPHS_ITEM_ACCESS_IGNORE;
  }

  return $permissions[$account->uid][$cid][$op];
}

/**
 * Implements hook_permission().
 */
function paragraphs_permission() {
  $perms = array(
    'administer paragraphs bundles' => array(
      'title' => t('Administer Paragraph types'),
      'description' => t('Is able to administer Paragraph types for the Paragraphs module'),
    ),
  );
  return $perms;
}

/**
 * Implements hook_menu().
 */
function paragraphs_menu() {
  $items = array();
  $items['admin/structure/paragraphs'] = array(
    'title' => 'Paragraphs types',
    'description' => 'Manage Paragraph types',
    'page callback' => 'paragraphs_admin_bundle_overview',
    'access arguments' => array('administer paragraphs bundles'),
    'file' => 'paragraphs.admin.inc',
  );

  $items['admin/structure/paragraphs/list'] = array(
    'title' => 'List Paragraphs types',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/structure/paragraphs/add'] = array(
    'title' => 'Add Paragraphs type',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_admin_bundle_form'),
    'access arguments' => array('administer paragraphs bundles'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'paragraphs.admin.inc',
  );

  $items['admin/structure/paragraphs/%paragraphs_bundle'] = array(
    'title' => 'Edit Paragraphs type',
    'title callback' => 'paragraphs_bundle_title_callback',
    'title arguments' => array(3),
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_admin_bundle_form', 3),
    'access arguments' => array('administer paragraphs bundles'),
    'file' => 'paragraphs.admin.inc',
  );

  $items['admin/structure/paragraphs/%paragraphs_bundle/configure'] = array(
    'title' => 'Configure',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/paragraphs/%paragraphs_bundle/delete'] = array(
    'title' => 'Delete Paragraphs type',
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_admin_bundle_delete_form', 3),
    'access arguments' => array('administer paragraphs bundles'),
    'type' => MENU_VISIBLE_IN_BREADCRUMB,
    'file' => 'paragraphs.admin.inc',
  );

  $items['paragraphs/%paragraphs_item/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_modal_admin_edit', 1),
    'access callback' => 'paragraphs_modal_admin_access',
    'access arguments' => array(1),
    'file' => 'paragraphs.admin.inc',
  );

  $items['paragraphs/%paragraphs_item/remove'] = array(
    'title' => 'Remove',
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_modal_admin_remove_confirm', 1),
    'access callback' => 'paragraphs_modal_admin_access',
    'access arguments' => array(1),
    'file' => 'paragraphs.admin.inc',
  );

  $items['paragraphs/%paragraphs_item/unpublish'] = array(
    'title' => 'Unpublish',
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_modal_admin_unpublish_confirm', 1),
    'access callback' => 'paragraphs_modal_admin_access',
    'access arguments' => array(1),
    'file' => 'paragraphs.admin.inc',
  );

  $items['paragraphs/%paragraphs_item/sort'] = array(
    'title' => 'Sort',
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_modal_admin_sort_form', 1),
    'access callback' => 'paragraphs_modal_admin_access',
    'access arguments' => array(1),
    'file' => 'paragraphs.admin.inc',
  );

  $items['paragraphs/add/%/%paragraphs_bundle/%/%/%'] = array(
    'title' => 'Add paragraph',
    'title callback' => 'paragraphs_add_title',
    'title arguments' => array(3),
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'backdrop_get_form',
    'page arguments' => array('paragraphs_modal_admin_add_form', 2, 3, 4, 5, 6),
    'access callback' => 'paragraphs_separate_create_access',
    'access arguments' => array(2, 3, 4, 5, 6),
    'file' => 'paragraphs.admin.inc',
  );

  return $items;
}

/**
 * Title callback for separate add page.
 */
function paragraphs_add_title($paragraphs_bundle) {
  return t('Add !bundle', array('!bundle' => $paragraphs_bundle->name));
}

/**
 * Implements hook_admin_bar_map().
 */
function paragraphs_admin_bar_map() {
  if (!user_access('administer paragraphs bundles')) {
    return;
  }
  $types = paragraphs_bundle_load();
  $type_keys = array();
  foreach ($types as $key => $type) {
    $type_keys[] = str_replace('_', '-', $key);
  }
  $map = array(
    'admin/structure/paragraphs/%paragraphs_bundle' => array(
      'parent' => 'admin/structure/paragraphs',
      'arguments' => array(
        array('%paragraphs_bundle' => $type_keys),
      ),
    ),
    'admin/structure/paragraphs/%paragraphs_bundle/edit' => array(
      'parent' => 'admin/structure/paragraphs/%paragraphs_bundle',
      'arguments' => array(
        array('%paragraphs_bundle' => $type_keys),
      ),
    ),
  );
  return $map;
}

/**
 * Implements hook_field_info().
 */
function paragraphs_field_info() {
  $info = array();
  $info['paragraphs'] = array(
    'label' => t('Paragraphs'),
    'description' => t('Paragraphs field using the Paragraph types.'),
    'instance_settings' => array(
      'title' => PARAGRAPHS_DEFAULT_TITLE,
      'title_multiple' => PARAGRAPHS_DEFAULT_TITLE_MULTIPLE,
      'allowed_bundles' => array(),
      'bundle_weights' => array(),
    ),
    'default_widget' => 'paragraphs_hidden',
    'default_formatter' => 'paragraphs_view',
    'settings' => array(),
    'property_type' => 'paragraphs_item',
    'property_callbacks' => array('paragraphs_entity_metadata_property_callback'),
  );
  return $info;
}

/**
 * Implements hook_form_field_ui_field_edit_form_alter().
 */
function paragraphs_form_field_ui_field_edit_form_alter(&$form, $form_state) {
  if ($form['#field']['type'] == 'paragraphs') {
    $form['#theme'] = array('paragraphs_bundle_settings_form');
    array_unshift($form['#submit'], 'paragraphs_bundle_settings_form_submit');
  }
  elseif ($form['#instance']['entity_type'] == 'paragraphs_item') {
    $form['actions']['delete']['#submit'][] = 'paragraphs_field_edit_form_submit';
  }
}

/**
 * Submit callback for paragraphs field settings form.
 *
 * @see paragraphs_form_field_ui_field_edit_form_alter
 */
function paragraphs_field_edit_form_submit($form, &$form_state) {
  $instance = $form['#instance'];
  $destination = backdrop_get_destination();
  $form_state['redirect'] = array('admin/structure/paragraphs/' . $instance['bundle'] . '/fields/' . $instance['field_name'] . '/delete', array('query' => $destination));
}

/**
 * Submit callback for paragraphs bundle settings form.
 *
 * @see paragraphs_form_field_ui_field_edit_form_alter
 */
function paragraphs_bundle_settings_form_submit($form, &$form_state) {
  $bundle_settings = array();
  $bundle_weights = array();
  if (isset($form_state['values']['instance']['settings']['allowed_bundles_table'])) {
    $bundle_settings_table = $form_state['values']['instance']['settings']['allowed_bundles_table'];
    backdrop_sort($bundle_settings_table, array('#weight'));
    foreach ($bundle_settings_table as $machine_name => $value) {
      $bundle_settings[$machine_name] = (($value['enabled'] === 1) ? $machine_name : -1);
      $bundle_weights[$machine_name] = $value['weight'];
    }
  }

  $form_state['values']['instance']['settings']['allowed_bundles'] = $bundle_settings;
  $form_state['values']['instance']['settings']['bundle_weights'] = $bundle_weights;

  unset($form_state['values']['instance']['settings']['allowed_bundles_table']);
}

/**
 * Implements hook_field_instance_settings_form().
 */
function paragraphs_field_instance_settings_form($field, $instance) {

  $settings = $instance['settings'];
  $bundles = array();
  $_bundles = paragraphs_bundle_load();
  $form_delta = count($_bundles) * 2;
  $max_weight = 0;
  $weights = array();

  foreach ($_bundles as $machine_name => $bundle) {
    $bundles[$machine_name] = $bundle->name;
    if (isset($settings['bundle_weights'][$machine_name])) {
      $weights[$machine_name] = $settings['bundle_weights'][$machine_name];
      if ($settings['bundle_weights'][$machine_name] > $max_weight) {
        $max_weight = $settings['bundle_weights'][$machine_name];
      }
    }
  }

  $max_weight++;

  $element['allowed_bundles_table'] = array(
    '#tree' => TRUE,
    '#prefix' => '<label>' . t('Allowed Paragraph types') . '</label>',
    '#suffix' => '<div class="description">' . t('If no Paragraph type is selected, all the types will be available.') . '</div>',
  );

  $weight = 1;
  foreach ($_bundles as $machine_name => $bundle) {

    $enabled = FALSE;
    if (isset($settings['allowed_bundles'][$machine_name]) && $settings['allowed_bundles'][$machine_name] === $machine_name) {
      $enabled = TRUE;
    }
    $element['allowed_bundles_table'][$machine_name] = array(
      'enabled' => array(
        '#type' => 'checkbox',
        '#title' => check_plain($bundle->name) . ' <em>(' . check_plain($bundle->label) . ')</em>',
        '#title_display' => 'after',
        '#default_value' => $enabled,
      ),
      'weight' => array(
        '#type' => 'weight',
        '#title' => t('Weight'),
        '#default_value' => (isset($weights[$machine_name]) ? $weights[$machine_name] : $weight + $max_weight),
        '#delta' => $form_delta,
        '#title_display' => 'invisible',
      ),
    );
    $element['allowed_bundles_table'][$machine_name]['#weight'] = $element['allowed_bundles_table'][$machine_name]['weight']['#default_value'];
    $weight++;
  }

  $element['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Item Title'),
    '#description' => t('Label to appear as title on the button as "Add new [title]", this label is translatable'),
    '#default_value' => isset($settings['title']) ? $settings['title'] : PARAGRAPHS_DEFAULT_TITLE,
    '#required' => TRUE,
  );

  $element['title_multiple'] = array(
    '#type' => 'textfield',
    '#title' => t('Plural Item Title'),
    '#description' => t('Title in its plural form.'),
    '#default_value' => isset($settings['title_multiple']) ? $settings['title_multiple'] : PARAGRAPHS_DEFAULT_TITLE_MULTIPLE,
    '#required' => TRUE,
  );

  $element['default_edit_mode'] = array(
    '#type' => 'select',
    '#title' => t('Default edit mode'),
    '#description' => t('The default edit mode the paragraph item is in. Preview will render the paragraph in the preview view mode.'),
    '#options' => array(
      'open' => t('Open'),
      'closed' => t('Closed'),
      'preview' => t('Preview'),
    ),
    '#default_value' => isset($settings['default_edit_mode']) ? $settings['default_edit_mode'] : PARAGRAPHS_DEFAULT_EDIT_MODE,
    '#required' => TRUE,
  );

  $element['default_edit_mode_override'] = array(
    '#type' => 'number',
    '#title' => t('Edit mode override'),
    '#title_display' => 'invisible',
    '#field_prefix' => t('Force items to display as "Open" when there are less then'),
    '#field_suffix' => t('items.'),
    '#default_value' => (isset($settings['default_edit_mode_override']) && !empty($settings['default_edit_mode_override'])) ? $settings['default_edit_mode_override'] : PARAGRAPHS_DEFAULT_EDIT_MODE_OVERRIDE,
    '#states' => array(
      // Hide the settings when the the default edit mode is set to "Open.".
      'invisible' => array(
        ':input[name="instance[settings][default_edit_mode]"]' => array('value' => 'open'),
      ),
    ),
    '#size' => 2,
    '#maxlength' => 2,
    // Specify width, since size property isn't supported on number fields.
    '#attributes' => array('style' => 'width:3em'),
    '#min' => 1,
    '#max' => 99,
  );

  $element['add_mode'] = array(
    '#type' => 'select',
    '#title' => t('Add mode'),
    '#description' => t('The way to add new paragraphs.'),
    '#options' => array(
      'select' => t('Select List'),
      'button' => t('Buttons'),
    ),
    '#default_value' => isset($settings['add_mode']) ? $settings['add_mode'] : PARAGRAPHS_DEFAULT_ADD_MODE,
    '#required' => TRUE,
  );

  $element['modal_admin'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable modal administration (experimental)'),
    '#description' => t('Enables a dropbutton per paragraph for performing administrative tasks in a modal dialog on the front end.'),
    '#default_value' => isset($settings['modal_admin']) ? $settings['modal_admin'] : PARAGRAPHS_DEFAULT_MODAL_ADMIN,
  );

  if (!count($bundles)) {
    $link = l(t('click here to add one'), 'admin/structure/paragraphs/add', array('query' => backdrop_get_destination()));
    $element['allowed_bundles_explain'] = array(
      '#type' => 'markup',
      '#markup' => t('You did not add any Paragraph types yet, !clickhere.', array('!clickhere' => $link)),
    );
  }

  $element['fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Default value'),
    '#collapsible' => FALSE,
    // As field_ui_default_value_widget() does, we change the #parents so that
    // the value below is writing to $instance in the right location.
    '#parents' => array('instance'),
  );
  // Be sure to set the default value to NULL, for example to repair old fields
  // that still have one.
  $element['fieldset']['default_value'] = array(
    '#type' => 'value',
    '#value' => NULL,
  );
  $element['fieldset']['content'] = array(
    '#pre' => '<p>',
    '#markup' => t('To specify a default value, configure it via the regular default value setting of each field that is part of the Paragraph type. To do so, go to the <a href="!url">Manage fields</a> screen of the Paragraph type.', array('!url' => url('admin/structure/paragraphs'))),
    '#suffix' => '</p>',
  );
  return $element;
}

/**
 * Theme function for paragraphs bundle settings form.
 *
 * @see paragraphs_form_field_ui_field_edit_form_alter
 */
function theme_paragraphs_bundle_settings_form($variables) {
  $form = $variables['form'];

  // Initialize the variable which will store our table rows.
  $rows = array();

  uasort($form['instance']['settings']['allowed_bundles_table'], 'element_sort');

  // Iterate over each element in our $form['example_items'] array.
  foreach (element_children($form['instance']['settings']['allowed_bundles_table']) as $id) {

    // Before we add our 'weight' column to the row, we need to give the
    // element a custom class so that it can be identified in the
    // backdrop_add_tabledrag call.
    //
    // This could also have been done during the form declaration by adding
    // '#attributes' => array('class' => 'example-item-weight'),
    // directy to the 'weight' element in tabledrag_example_simple_form().
    $form['instance']['settings']['allowed_bundles_table'][$id]['weight']['#attributes']['class'] = array('paragraphs-bundle-item-weight');

    // We are now ready to add each element of our $form data to the $rows
    // array, so that they end up as individual table cells when rendered
    // in the final table.  We run each element through the backdrop_render()
    // function to generate the final html markup for that element.
    $rows[] = array(
      'data' => array(
        // Add our 'enabled' column.
        backdrop_render($form['instance']['settings']['allowed_bundles_table'][$id]['enabled']),
        // Add our 'weight' column.
        backdrop_render($form['instance']['settings']['allowed_bundles_table'][$id]['weight']),
      ),
      // To support the tabledrag behaviour, we need to assign each row of the
      // table a class attribute of 'draggable'. This will add the 'draggable'
      // class to the <tr> element for that row when the final table is
      // rendered.
      'class' => array('draggable'),
    );
  }

  // We now define the table header values.  Ensure that the 'header' count
  // matches the final column count for your table.
  $header = array(t('Paragraph Type'), t('Weight'));

  // We also need to pass the backdrop_add_tabledrag() function an id which will
  // be used to identify the <table> element containing our tabledrag form.
  // Because an element's 'id' should be unique on a page, make sure the value
  // you select is NOT the same as the form ID used in your form declaration.
  $table_id = backdrop_html_id('paragraphs-bundle-table');

  // We can render our tabledrag table for output.
  $output = theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('id' => $table_id),
  ));

  $form['instance']['settings']['allowed_bundles_table']['#markup'] = $output;

  // And then render any remaining form elements (such as our submit button).
  $output = backdrop_render_children($form);

  // We now call the backdrop_add_tabledrag() function in order to add the
  // tabledrag.js goodness onto our page.
  //
  // For a basic sortable table, we need to pass it:
  // - the $table_id of our <table> element,
  // - the $action to be performed on our form items ('order'),
  // - a string describing where $action should be applied ('siblings'),
  // - and the class of the element containing our 'weight' element.
  backdrop_add_tabledrag($table_id, 'order', 'sibling', 'paragraphs-bundle-item-weight');

  return $output;
}

/**
 * Implements hook_field_settings_form().
 */
function paragraphs_field_settings_form($field, $instance) {

  $form = array();
  return $form;
}

/**
 * Implements hook_field_presave().
 *
 * Support saving paragraph items in @code $item['entity'] @endcode. This
 * may be used to seamlessly create paragraph items during host-entity
 * creation or to save changes to the host entity and its collections at once.
 */
function paragraphs_field_presave($host_entity_type, $host_entity, $field, $instance, $langcode, &$items) {
  $top_host = $host_entity;
  while (method_exists($top_host, 'hostEntity')) {
    $top_host = $top_host->hostEntity();
  }

  // Prevent workbench moderation from deleting paragraphs on node_save()
  // during workbench_moderation_store(), when $host_entity->revision == 0.
  if (!empty($top_host->workbench_moderation['updating_live_revision'])) {
    return;
  }

  foreach ($items as $key => &$item) {
    // In case the entity has been changed / created, save it and set the id.
    // If the host entity creates a new revision, save new item-revisions as
    // well.
    $entity = FALSE;
    if (isset($item['entity'])) {
      $entity = paragraphs_field_get_entity($item);
    }
    elseif (isset($item['revision_id'])) {
      $entity = paragraphs_item_revision_load($item['revision_id']);
    }

    if ($entity) {
      $entity->setHostEntity($host_entity_type, $host_entity, $langcode, FALSE);

      // If the host entity supports revisions and is saved as new revision, do
      // the same for the item.
      if (!empty($host_entity->revision)) {
        $entity->revision = TRUE;
        $is_default = entity_plus_revision_is_default($host_entity_type, $host_entity);
        // If an entity type does not support saving non-default entities,
        // assume it will be saved as default.
        if (!isset($is_default) || $is_default) {
          $entity->default_revision = TRUE;
          $entity->archived = FALSE;
        }
      }

      if (isset($entity->removed) && $entity->removed) {
        unset($items[$key]);
      }
      else {
        // Update status from form item.
        if (isset($item['status'])) {
          $entity->status = $item['status'];
        }

        $entity->save(TRUE);

        $item = array(
          'value' => $entity->item_id,
          'revision_id' => $entity->revision_id,
        );
      }
    }
  }
}

/**
 * Implements hook_field_update().
 *
 * Care about removed paragraph items.
 */
function paragraphs_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // Prevent workbench moderation from deleting paragraphs on node_save() during
  // workbench_moderation_store(), when $host_entity->revision == 0.
  if (!empty($entity->workbench_moderation['updating_live_revision'])) {
    return;
  }
  // Prevent State Flow Entity from deleting paragraphs on node_save()
  // when adding new paragraphs item and a published revision of the node exist.
  // @see state_flow_entity_exit().
  if (!empty($entity->state_flow) && isset($entity->revision) && $entity->revision === FALSE) {
    return;
  }

  $items_original = !empty($entity->original->{$field['field_name']}[$langcode]) ? $entity->original->{$field['field_name']}[$langcode] : array();
  $original_by_id = array_flip(paragraphs_field_item_to_ids($items_original));

  foreach ($items as $item) {
    unset($original_by_id[$item['value']]);
  }

  // If there are removed items, care about deleting the item entities.
  if ($original_by_id) {
    $ids = array_flip($original_by_id);

    // If we are creating a new revision, the old-items should be kept but get
    // marked as archived now.
    if (!empty($entity->revision)) {
      db_update('paragraphs_item')
        ->fields(array('archived' => 1))
        ->condition('item_id', $ids, 'IN')
        ->execute();
    }
    else {
      // Delete unused paragraph items now.
      foreach (paragraphs_item_load_multiple($ids) as $item) {
        $item->setHostEntity($entity_type, $entity, $langcode, FALSE);
        $item->deleteRevision(TRUE);
      }
    }
  }
}

/**
 * Implements hook_field_delete().
 */
function paragraphs_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'paragraphs') {
    // Also delete all embedded entities.
    if ($ids = paragraphs_field_item_to_ids($items)) {
      // We filter out entities that are still being referenced by other
      // host-entities. This should never be the case, but it might happen e.g.
      // when modules clone a node without knowing about paragraphs.
      $entity_info = entity_get_info($entity_type);
      $entity_id_name = $entity_info['entity keys']['id'];
      $field_column = key($field['columns']);

      // Extra check to make sure our field exists.
      if (is_scalar($field)) {
        $field_definition = field_info_field($field['field_name']);
        if (!empty($field_definition)) {
          foreach ($ids as $id_key => $id) {
            $query = new EntityFieldQuery();
            $entities = $query
              ->fieldCondition($field['field_name'], $field_column, $id)
              ->execute();
            unset($entities[$entity_type][$entity->$entity_id_name]);

            if (!empty($entities[$entity_type])) {
              // Filter this $id out.
              unset($ids[$id_key]);
            }
          }
        }
      }

      entity_delete_multiple('paragraphs_item', $ids);
    }
  }
}

/**
 * Implements hook_field_delete_revision().
 */
function paragraphs_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'paragraphs') {
    foreach ($items as $item) {
      if (!empty($item['revision_id'])) {
        if ($paragraphs_item = entity_plus_revision_load('paragraphs_item', $item['revision_id'])) {
          $paragraphs_item->setHostEntity($entity_type, $entity, $langcode, FALSE);
          $paragraphs_item->deleteRevision(TRUE);
        }
      }
    }
  }
}

/**
 * Get an array of paragraph item IDs stored in the given field items.
 */
function paragraphs_field_item_to_ids($items) {
  $ids = array();
  foreach ($items as $item) {
    if (!empty($item['value'])) {
      $ids[] = $item['value'];
    }
  }
  return $ids;
}

/**
 * Implements hook_field_is_empty().
 */
function paragraphs_field_is_empty($item, $field) {
  // Item is empty when we removed it.
  if (isset($item['entity']) && ((isset($item['entity']->removed) && $item['entity']->removed) || (isset($item['entity']->confirmed_removed) && $item['entity']->confirmed_removed))) {
    return TRUE;
  }
  if (!empty($item['value'])) {
    return FALSE;
  }
  elseif (isset($item['entity']) && ($instances = field_info_instances('paragraphs_item', $item['entity']->bundle)) && !empty($instances)) {
    // With a valid instance we can re-use the "field is empty" hook.
    return paragraphs_item_is_empty($item['entity']);
  }
  elseif (isset($item['entity'])) {
    // Because of hook_entity_view_alter, the content comes from a view but not
    // stored in a field.
    return FALSE;
  }
  return TRUE;
}

/**
 * Determines whether a paragraphs field item is empty.
 */
function paragraphs_item_is_empty(ParagraphsItemEntity $item) {
  $instances = field_info_instances('paragraphs_item', $item->bundle);
  $is_empty = TRUE;

  foreach ($instances as $instance) {
    $field_name = $instance['field_name'];
    $field = field_info_field($field_name);

    // Determine the list of languages to iterate on.
    $languages = field_available_languages('paragraphs_item', $field);

    foreach ($languages as $langcode) {
      if (!empty($item->{$field_name}[$langcode])) {
        // If at least one paragraph is not empty; the
        // paragraph item is not empty.
        foreach ($item->{$field_name}[$langcode] as $field_item) {
          if (!module_invoke($field['module'], 'field_is_empty', $field_item, $field)) {
            $is_empty = FALSE;
          }
        }
      }
    }
  }

  // Allow other modules a chance to alter the value before returning.
  backdrop_alter('paragraphs_is_empty', $is_empty, $item);
  return $is_empty;
}

/**
 * Load a specific bundle or a list of bundles.
 *
 * @param string|null $name
 *   The machine name or list of bundles to load when null.
 * @param bool $rebuild
 *   Whether to use cache or not.
 *
 * @return array|object|bool
 *   The bundle, a list of bundles, or FALSE when not found.
 */
function paragraphs_bundle_load($name = NULL, $rebuild = FALSE) {
  $cid = 'paragraphs_bundles';
  $bundles = array();

  // Load bundles from static or from Backdrop cache.
  $_bundles = &backdrop_static($cid);
  if (isset($_bundles) && !$rebuild) {
    $bundles = $_bundles;
  }
  else {
    $_bundles = cache_get($cid);
    if ($_bundles && !$rebuild) {
      $bundles = $_bundles->data;
    }
    else {
      $config_names = config_get_names_with_prefix('paragraphs.type.');
      foreach ($config_names as $config_name) {
        $type = str_replace('paragraphs.type.', '', $config_name);
        $bundles[$type] = (object) config_get($config_name);
      }
      cache_set($cid, $bundles);
    }
    $_bundles = $bundles;
  }

  if ($name) {
    $name = strtr($name, array('-' => '_'));
    if (isset($bundles[$name])) {
      return $bundles[$name];
    }
    return FALSE;
  }
  else {
    return $bundles;
  }
}

/**
 * Function to create or update an paragraphs bundle.
 *
 * @param object $bundle
 *   The object of the bundle to create/update.
 *
 * @return int
 *   SAVED_UPDATED when updated, SAVED_NEW when created.
 *
 * @throws Exception
 */
function paragraphs_bundle_save($bundle) {
  $config = config('paragraphs.type.' . $bundle->bundle);

  if ($config->isNew()) {
    $status = SAVED_NEW;
  }
  else {
    $status = SAVED_UPDATED;
  }

  $bundle_data = array(
    'bundle' => (string) $bundle->bundle,
    'name' => (string) $bundle->name,
    'label' => (string) $bundle->label,
    'description' => (string) $bundle->description,
    'locked' => (int) $bundle->locked,
    'allow_unpublish' => (int) $bundle->allow_unpublish,
  );
  foreach ($bundle_data as $key => $value) {
    $config->set($key, $value);
  }
  $config->save();
  paragraphs_bundle_load(NULL, TRUE);
  entity_info_cache_clear();
  state_set('menu_rebuild_needed', TRUE);
  return $status;
}

/**
 * Function to delete a bundle.
 *
 * @param string $bundle_machine_name
 *   Machine name of the bundle to delete.
 */
function paragraphs_bundle_delete($bundle_machine_name) {
  $bundle = paragraphs_bundle_load($bundle_machine_name);
  if (is_object($bundle)) {
    // Delete config files.
    $config = config('paragraphs.type.' . $bundle->bundle);
    $config->delete();
    $sub_names = config_get_names_with_prefix('field.instance.paragraphs_item.' . $bundle->bundle . '.');
    foreach ($sub_names as $sub_name) {
      config($sub_name)->delete();
    }
    field_attach_delete_bundle('paragraphs_item', $bundle->bundle);
    paragraphs_bundle_load(NULL, TRUE);
    entity_info_cache_clear();
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Helper to get the title of a bundle.
 *
 * @param object $bundle
 *   The object of the bundle to get the title for.
 */
function paragraphs_bundle_title_callback($bundle) {
  return t('!name', array('!name' => $bundle->name));
}

/**
 * Entity property info setter callback for the host entity property.
 *
 * As the property is of type entity, the value will be passed as a wrapped
 * entity.
 */
function paragraphs_item_set_host_entity($item, $property_name, $wrapper) {
  if (empty($item->is_new)) {
    throw new EntityMetadataWrapperException('The host entity may be set only during creation of a paragraphs item.');
  }
  $item->setHostEntity($wrapper->type(), $wrapper->value());
}

/**
 * Entity property info getter callback for the host entity property.
 *
 * As the property is of type 'entity', we have to return a wrapped entity.
 */
function paragraphs_item_get_host_entity($item) {
  // We need to call hostEntity() first, because it sets the hostEntityType.
  $entity = $item->hostEntity();
  return entity_metadata_wrapper($item->hostEntityType(), $entity);
}

/**
 * Callback for generating entity metadata property info for a field instance.
 *
 * @see paragraphs_field_info()
 */
function paragraphs_entity_metadata_property_callback(&$info, $entity_type, $field, $instance, $field_type) {
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$field['field_name']];

  $property['field_name'] = $field['field_name'];
  $property['getter callback'] = 'paragraphs_field_property_get';
  $property['setter callback'] = 'paragraphs_field_property_set';
}

/**
 * Entity property info getter callback for the paragraph items.
 *
 * Like entity_metadata_field_property_get(), but additionally supports getting
 * not-yet saved collection items from @code $item['entity'] @endcode.
 */
function paragraphs_field_property_get($entity, array $options, $name, $entity_type, $info) {
  $field = field_info_field($name);
  $langcode = field_language($entity_type, $entity, $name, isset($options['language']) ? $options['language']->language : NULL);
  $values = array();
  if (isset($entity->{$name}[$langcode])) {
    foreach ($entity->{$name}[$langcode] as $delta => $data) {
      // Wrappers do not support multiple entity references being revisions or
      // not yet saved entities. In the case of a single reference we can return
      // the entity object though.
      if ($field['cardinality'] == 1) {
        $values[$delta] = paragraphs_field_get_entity($data);
      }
      elseif (isset($data['value'])) {
        $values[$delta] = $data['value'];
      }
    }
  }
  // For an empty single-valued field, we have to return NULL.
  return $field['cardinality'] == 1 ? ($values ? reset($values) : NULL) : $values;
}

/**
 * Entity property info setter callback for the paragraph items.
 *
 * Like entity_metadata_field_property_set(), but supports setting items with
 * revision identifiers.
 */
function paragraphs_field_property_set($entity, $name, $value, $langcode, $entity_type) {
  $field = field_info_field($name);
  $columns = array_keys($field['columns']);
  $langcode = entity_plus_metadata_field_get_language($entity_type, $entity, $field, $langcode);
  $values = $field['cardinality'] == 1 ? array($value) : (array) $value;

  $items = array();
  foreach ($values as $delta => $value) {
    if (isset($value)) {
      if ($value instanceof ParagraphsItemEntity) {
        $items[$delta][$columns[0]] = $value->item_id;
        $items[$delta][$columns[1]] = $value->revision_id;
      }
      elseif (is_array($value) && isset($value['value']) && isset($value['revision_id'])) {
        $items[$delta][$columns[0]] = $value['value'];
        $items[$delta][$columns[1]] = $value['revision_id'];
      }
      else {
        $item = paragraphs_item_load($value);
        $items[$delta][$columns[0]] = $item->item_id;
        $items[$delta][$columns[1]] = $item->revision_id;
      }
    }
  }
  $entity->{$name}[$langcode] = $items;
  // Empty the static field language cache, so the field system picks up any
  // possible new languages.
  backdrop_static_reset('field_language');
}

/**
 * Gets a paragraphs item entity for a given field item.
 *
 * @param string $field_name
 *   (optional) If given and there is no entity yet, a new entity object is
 *   created for the given item.
 *
 * @return object|bool
 *   The entity object or FALSE.
 */
function paragraphs_field_get_entity(&$item, $bundle = NULL, $field_name = NULL) {
  if (isset($item['entity'])) {
    return $item['entity'];
  }
  elseif (isset($item['value'])) {
    // By default always load the default revision, so caches get used.
    $entity = paragraphs_item_load($item['value']);
    if ($entity && $entity->revision_id != $item['revision_id']) {
      // A non-default revision is a referenced, so load this one.
      $entity = entity_plus_revision_load('paragraphs_item', $item['revision_id']);
    }
    return $entity;
  }
  elseif (!isset($item['entity']) && isset($bundle) && isset($field_name)) {
    $item['entity'] = entity_create('paragraphs_item', array('bundle' => $bundle, 'field_name' => $field_name));
    return $item['entity'];
  }
  return FALSE;
}

/**
 * Returns HTML for an individual form element.
 *
 * Combine multiple values into a table with drag-n-drop reordering.
 * TODO : convert to a template.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: A render element representing the form element.
 *
 * @return string
 *   An html string.
 *
 * @ingroup themeable
 */
function theme_paragraphs_field_multiple_value_form(array $variables) {
  $element = $variables['element'];
  $output = '';
  $instance = $element['#instance'];

  if (!isset($instance['settings']['title'])) {
    $instance['settings']['title'] = PARAGRAPHS_DEFAULT_TITLE;
  }
  if (!isset($instance['settings']['title_multiple'])) {
    $instance['settings']['title_multiple'] = PARAGRAPHS_DEFAULT_TITLE_MULTIPLE;
  }

  $add_mode = (isset($instance['settings']['add_mode']) ? $instance['settings']['add_mode'] : PARAGRAPHS_DEFAULT_ADD_MODE);

  $required = !empty($element['#required']) ? theme('form_required_marker', $variables) : '';

  // Sort items according to '_weight' (needed when the form comes back after
  // preview or failed validation).
  $items = array();
  foreach (element_children($element) as $key) {
    if ($key === 'add_more') {
      $add_more_button = &$element[$key];
    }
    elseif ($key === 'add_more_type') {
      $add_more_button_type = &$element[$key];
    }
    else {
      if (!isset($element[$key]['#access']) || $element[$key]['#access']) {
        $items[] = &$element[$key];
      }
    }
  }
  usort($items, '_field_sort_items_value_helper');

  // If the field can hold more than one item, display it as a draggable table.
  if ($element['#cardinality'] != 1) {
    $table_id = backdrop_html_id($element['#field_name'] . '_values');
    $order_class = $element['#field_name'] . '-' . $table_id . '-delta-order';

    $header = array(
      array(
        'data' => '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . '</label>',
        'colspan' => 2,
        'class' => array('field-label'),
      ),
      t('Order'),
    );
    $rows = array();

    // Add the items as table rows.
    foreach ($items as $key => $item) {
      $item['_weight']['#attributes']['class'] = array($order_class);
      $delta_element = backdrop_render($item['_weight']);
      $cells = array(
        array(
          'data' => '',
          'class' => array('field-multiple-drag'),
        ),
        backdrop_render($item),
        array(
          'data' => $delta_element,
          'class' => array('delta-order'),
        ),
      );
      $class = !empty($item['#bundle']) ? array('draggable', backdrop_html_class('paragraphs_item_type_' . $item['#bundle'])) : array();
      $rows[] = array(
        'data' => $cells,
        'class' => $class,
      );
    }

    $field_content = theme('table', array(
      'header' => $header,
      'rows' => $rows,
      'attributes' => array(
        'id' => $table_id,
        'class' => array('field-multiple-table'),
      ),
    ));

    backdrop_add_tabledrag($table_id, 'order', 'sibling', $order_class);
  }
  // If the field can only hold one item, display it without the table wrapper.
  else {
    $value_id = backdrop_html_id($element['#field_name'] . '_value');
    $field_content = '<label for="' . $value_id . '">' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . '</label>';
    if (count($items)) {
      // We don't need to render a weight field when there can only be one item.
      unset($items[0]['_weight']);
      $field_content .= '<div id="' . $value_id . '">' . backdrop_render($items[0]) . '</div>';
    }
  }

  $output = '<div class="form-item">';
  if (count($items)) {
    $output .= $field_content;
  }
  else {
    $replacements = array(
      '@title_multiple' => t('@title', array('@title' => $instance['settings']['title_multiple'])),
      '@title' => t('@title', array('@title' => $instance['settings']['title'])),
    );

    if (count($element['#select_bundles']) === 1) {
      if ($element['#cardinality'] == 1) {
        $add_text = t('The @title has not been added yet. Press the button below to add it.', $replacements);
      }
      else {
        $add_text = t('No @title_multiple added yet. Press the button below to add one.', $replacements);
      }
    }
    elseif ($add_mode == 'button') {
      $add_text = t('No @title_multiple added yet. Select a @title type and press a button below to add one.', $replacements);
    }
    else {
      $add_text = t('No @title_multiple added yet. Select a @title type and press the button below to add one.', $replacements);
    }

    $output .= '<label>' . t('!title !required', array('!title' => $element['#title'], '!required' => $required)) . "</label>";
    $output .= '<p><em>' . $add_text . '</em></p>';
  }
  $output .= $element['#description'] ? '<div class="description">' . $element['#description'] . '</div>' : '';
  $output .= '<div class="clearfix">' . backdrop_render($add_more_button_type) . backdrop_render($add_more_button) . '</div>';
  $output .= '</div>';

  return $output;
}

/**
 * Implements hook_theme().
 */
function paragraphs_theme() {
  return array(
    'paragraphs_field_multiple_value_form' => array(
      'render element' => 'element',
    ),
    'paragraphs_bundle_settings_form' => array(
      'render element' => 'form',
    ),
    'paragraphs_modal_admin_sort_form' => array(
      'render element' => 'form',
    ),
    'paragraphs_items' => array(
      'render element' => 'element',
      'template' => 'paragraphs-items',
      'path' => backdrop_get_path('module', 'paragraphs') . '/theme',
      'file' => 'paragraphs.theme.inc',
    ),
    'paragraphs_item' => array(
      'render element' => 'elements',
      'template' => 'paragraphs-item',
      'path' => backdrop_get_path('module', 'paragraphs') . '/theme',
      'file' => 'paragraphs.theme.inc',
    ),
  );
}

/**
 * Implements hook_field_create_field().
 */
function paragraphs_field_create_field($field) {
  if ($field['type'] == 'paragraphs') {

    // Clear caches.
    entity_info_cache_clear();
    // Do not directly issue menu rebuilds here to avoid potentially multiple
    // rebuilds. Instead, let menu_get_item() issue the rebuild on the next
    // request.
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_field_delete_field().
 */
function paragraphs_field_delete_field($field) {
  if ($field['type'] == 'paragraphs') {

    // Clear caches.
    entity_info_cache_clear();
    // Do not directly issue menu rebuilds here to avoid potentially multiple
    // rebuilds. Instead, let menu_get_item() issue the rebuild on the next
    // request.
    state_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_views_api().
 */
function paragraphs_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => backdrop_get_path('module', 'paragraphs') . '/views',
  );
}

/**
 * Implements hook_module_implements_alter().
 */
function paragraphs_module_implements_alter(&$implementations, $hook) {
  switch ($hook) {
    case 'field_attach_form':
      // We put the implementation of field_attach_form implementation of
      // paragraphs at the end, so it has a chance to disable the implementation
      // of entity_translation that provides the form changes that will break
      // paragraphs.
      $group = $implementations['paragraphs'];
      unset($implementations['paragraphs']);
      $implementations['paragraphs'] = $group;
      break;
  }
}

/**
 * Implements hook_field_attach_form().
 */
function paragraphs_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {

  // We make sure paragraphs don't use the entity translation defaults, as those
  // are not implemented properly yet in paragraphs. So we better show an empty
  // initial field for a translation of an existing entity, than making
  // paragraphs break completely.
  // A proper implementation of entity_translation has still to be discussed.
  // @see https://drupal.org/node/2152931
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);

  foreach (field_info_instances($entity_type, $bundle) as $instance) {

    $field_name = $instance['field_name'];
    $field_info = field_info_field($field_name);

    if ($field_info['type'] == 'paragraphs') {
      if (isset($form[$field_name])) {
        $element = &$form[$field_name];

        // Remove the entity_translation preparion for the element. This way we
        // avoid that there will be form elements that do not have a
        // corresponding form state for the field.
        if (!empty($element['#process'])) {
          $key = array_search('entity_translation_prepare_element', $element['#process']);

          if ($key !== FALSE) {
            unset($element['#process'][$key]);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_field_prepare_translation().
 *
 * @see field_attach_prepare_translation()
 */
function paragraphs_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &$items, $source_entity, $source_langcode) {
  if (!module_exists("paragraphs_i18n")) {
    list($id, ,) = entity_extract_ids($entity_type, $entity);

    // The field_attach_prepare_translation() function copied the entity ids
    // from the source, but as we need a new entity for a new translation, we
    // cannot reuse that.
    // To clone existing paragraphs to the new translation, see the Replicate
    // and Replicate Paragraphs modules.
    if (empty($id)) {
      $items = array();
    }
  }
  else {
    paragraphs_i18n_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, $items, $source_entity, $source_langcode);
  }
}

/**
 * Implements hook_bundle_copy_info().
 */
function paragraphs_bundle_copy_info() {
  return array(
    'paragraphs_item' => array(
      'bundle_export_callback' => 'paragraphs_bundle_load',
      'bundle_save_callback' => 'paragraphs_bundle_save',
      'export_menu' => array(
        'path' => 'admin/structure/paragraphs/export',
        'access arguments' => 'administer content types',
      ),
      'import_menu' => array(
        'path' => 'admin/structure/paragraphs/import',
        'access arguments' => 'administer content types',
      ),
    ),
  );
}

/**
 * Helper to ensure entitycache table.
 */
function paragraphs_ensure_entitycache_table() {
  if (!db_table_exists('cache_entity_paragraphs_item')) {
    $cache_schema = backdrop_get_schema_unprocessed('system', 'cache');
    $cache_schema['description'] = 'Cache table used to store paragraphs_item entity records.';
    db_create_table('cache_entity_paragraphs_item', $cache_schema);
  }
}

/**
 * Helper to remove entitycache table.
 */
function paragraphs_remove_entitycache_table() {
  if (db_table_exists('cache_entity_paragraphs_item')) {
    db_drop_table('cache_entity_paragraphs_item');
  }
}

/**
 * Implements hook_modules_installed().
 */
function paragraphs_modules_installed($modules) {
  if (in_array('entitycache', $modules)) {
    paragraphs_ensure_entitycache_table();
  }
}

/**
 * Implements hook_modules_uninstalled().
 */
function paragraphs_modules_uninstalled($modules) {
  if (in_array('entitycache', $modules)) {
    paragraphs_remove_entitycache_table();
  }
}

/**
 * Access callback for separate edit/sort/delete form.
 *
 * @var ParagraphsItemEntity $paragraphs_item
 */
function paragraphs_modal_admin_access($paragraphs_item) {
  $paragraphs_item->hostEntity();
  $host_entity_type = $paragraphs_item->hostEntityType();
  $instance = $paragraphs_item->instanceInfo();

  // Check separate forms are enabled and that the user has access to update
  // the host entity as well as the paragraph item itself.
  return !empty($instance['settings']['modal_admin']) && entity_access('update', $host_entity_type, $paragraphs_item->hostEntity()) && entity_access('update', 'paragraphs_item', $paragraphs_item);
}

/**
 * Access callback for separate add form.
 */
function paragraphs_separate_create_access($mode, $paragraphs_bundle, $host_entity_type, $entity_id, $field_name) {
  if (!$entity_id && !in_array($mode, array('scratch', 'before', 'after'))) {
    return FALSE;
  }

  if ($mode == 'scratch') {
    // Load host entity to get field instance info.
    $host_entity = entity_load($host_entity_type, array($entity_id));
    $host_entity = reset($host_entity);
    $entity_info = entity_extract_ids($host_entity_type, $host_entity);
    $instance = field_info_instance($host_entity_type, $field_name, $entity_info[2]);
  }
  else {
    // Load paragraphs item to get field instance info.
    $paragraphs_item = paragraphs_item_load_multiple(array($entity_id));
    $paragraphs_item = reset($paragraphs_item);
    $host_entity = $paragraphs_item->hostEntity();
    $instance = $paragraphs_item->instanceInfo();
  }

  // Check if separate forms are enabled and we can update the host entity.
  return !empty($instance['settings']['modal_admin']) && entity_access('update', $host_entity_type, $host_entity);
}


/**
 * Generate dropbuttons for modal administration.
 */
function paragraphs_modal_admin_links($paragraphs_item) {
  $paragraph_id = $paragraphs_item->item_id;
  $field_info = $paragraphs_item->fieldInfo();
  $bundle = paragraphs_bundle_load($paragraphs_item->bundle);
  $access = paragraphs_modal_admin_access($paragraphs_item);
  $host_entity = $paragraphs_item->hostEntity();
  $host_entity_type = $paragraphs_item->hostEntityType();
  $host_entity_id = $paragraphs_item->hostEntityId();
  $host_entity_bundle = $paragraphs_item->hostEntityBundle();
  $field_name = $paragraphs_item->field_name;
  $langcode = $paragraphs_item->langcode;
  $field = field_info_field($field_name);
  $instance = field_info_instance($host_entity_type, $field_name, $host_entity_bundle);
  $admin_links = array();

  // Set up array of links.
  $classes = array(
    'use-ajax',
  );
  if (module_exists('font_awesome')) {
    $classes[] = 'font-awesome';
  }
  if (is_numeric($paragraph_id) && $access) {
    $admin_links = array(
      '#type' => 'dropbutton',
      '#attributes' => array(
        'class' => array('paragraphs-admin-dropbutton'),
      ),
      '#links' => array(
        'paragraphs_admin_edit' => array(
          'title' => t('Edit'),
          'href' => 'paragraphs/' . $paragraph_id . '/edit',
          'attributes' => array(
            'class' => array_merge(array('paragraphs-edit'), $classes),
            'data-dialog' => TRUE,
            'data-dialog-options' => json_encode(array(
              'dialogClass' => 'paragraphs-admin-links-dialog',
              'width' => 700,
              'draggable' => TRUE,
            )),
          ),
        ),
        'paragraphs_admin_remove' => array(
          'title' => t('Remove'),
          'href' => 'paragraphs/' . $paragraph_id . '/remove',
          'attributes' => array(
            'class' => array_merge(array('paragraphs-remove'), $classes),
            'data-dialog' => TRUE,
            'data-dialog-options' => json_encode(array(
              'dialogClass' => 'paragraphs-admin-links-dialog',
              'width' => 700,
              'draggable' => TRUE,
            )),
          ),
        ),
      ),
    );
    if (!empty($bundle->allow_unpublish)) {
      $admin_links['#links']['paragraphs_admin_unpublish'] = array(
        'title' => t('Unpublish'),
        'href' => 'paragraphs/' . $paragraph_id . '/unpublish',
        'attributes' => array(
          'class' => array_merge(array('paragraphs-unpublish'), $classes),
          'data-dialog' => TRUE,
          'data-dialog-options' => json_encode(array(
            'dialogClass' => 'paragraphs-admin-links-dialog',
            'width' => 700,
            'draggable' => TRUE,
          )),
        ),
      );
    }
    if ($field_info['cardinality'] != '1' && count($host_entity->{$field_info['field_name']}[$langcode]) > 1) {
      $admin_links['#links']['paragraphs_admin_sort'] = array(
        'title' => t('Sort'),
        'href' => 'paragraphs/' . $paragraph_id . '/sort',
        'attributes' => array(
          'class' => array_merge(array('paragraphs-sort'), $classes),
          'data-dialog' => TRUE,
          'data-dialog-options' => json_encode(array(
            'dialogClass' => 'paragraphs-admin-links-dialog',
            'width' => 700,
            'draggable' => TRUE,
          )),
        ),
      );
    }

    // Determine which bundles can be added.
    $available_bundles = paragraphs_bundle_load();
    $select_bundles = array();
    $select_bundles_weighted = array();

    // By default, consider that no bundle has been explicitly picked.
    $explicitly_enabled = FALSE;
    foreach ($instance['settings']['allowed_bundles'] as $allowed_bundle_key => $allowed_bundle_value) {
      if ($allowed_bundle_key === $allowed_bundle_value && isset($available_bundles[$allowed_bundle_key])) {
        $select_bundles[$available_bundles[$allowed_bundle_key]->bundle] = $available_bundles[$allowed_bundle_key]->label;

        // If an item has been explicitly selected, raise our flag.
        $explicitly_enabled = TRUE;
      }
      elseif (isset($available_bundles[$allowed_bundle_key]->bundle)) {
        $select_bundles_weighted[$available_bundles[$allowed_bundle_key]->bundle] = $available_bundles[$allowed_bundle_key]->label;
      }
    }

    // If no bundle has been explicitly selected, give access to all of them.
    if (!$explicitly_enabled) {
      $select_bundles = $select_bundles_weighted;
      foreach ($available_bundles as $bundle) {
        if (!isset($select_bundles[$bundle->bundle])) {
          $select_bundles[$bundle->bundle] = $bundle->label;
        }
      }
    }

    $removed_a_bundle = FALSE;

    $weight = 0;

    foreach ($select_bundles as $machine_name => $bundle) {
      $select_bundles[$machine_name] = array(
        'name' => $bundle,
        'weight' => $weight,
      );

      /* @var $entity_shell ParagraphsItemEntity */
      $entity_shell = entity_create('paragraphs_item', array('bundle' => $machine_name, 'field_name' => $field_name));
      $entity_shell->setHostEntity($host_entity_type, $host_entity, $langcode, FALSE);

      if (!entity_access('create', 'paragraphs_item', $entity_shell)) {
        unset($select_bundles[$machine_name]);
        $removed_a_bundle = TRUE;
      }
      elseif (isset($instance['settings']['bundle_weights'][$machine_name])) {
        $select_bundles[$machine_name]['weight'] = $instance['settings']['bundle_weights'][$machine_name];
      }
      $weight++;
    }

    if (count($select_bundles)) {
      backdrop_sort($select_bundles, array('weight' => SORT_NUMERIC));

      if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $field_state['real_items_count'] < $field['cardinality']) {
        foreach ($select_bundles as $key => $bundle) {
          $admin_links['#links']['paragraphs_admin_add_' . $key] = array(
            'title' => t('Add new') . ' ' . $bundle['name'],
            'href' => "paragraphs/add/scratch/$key/$host_entity_type/$host_entity_id/$field_name",
            'attributes' => array(
              'class' => array_merge(array('paragraphs-add'), $classes),
              'data-dialog' => TRUE,
              'data-dialog-options' => json_encode(array(
                'dialogClass' => 'paragraphs-admin-links-dialog',
                'width' => 700,
                'draggable' => TRUE,
              )),
            ),
          );
        }
      }
    }

    $admin_links['#attached']['js'][] = array(
      'data' => backdrop_get_path('module', 'paragraphs') . '/js/paragraphs_modal_admin.js',
      'type' => 'file',
      'scope' => 'footer',
    );
    $admin_links['#attached']['library'][] = array('system', 'backdrop.ajax');
  }
  return $admin_links;
}

/**
 * Retrieves contextual links for a path based on registered local tasks.
 *
 * @see menu_contextual_links()
 */
function paragraphs_contextual_links($args) {
  $links = array();

  $data = &backdrop_static(__FUNCTION__);
  if (!isset($data)) {
    $data = paragraphs_get_router_items('paragraphs/%');
  }

  array_unshift($args, 'paragraphs');
  foreach ($data as $item) {
    // Extract the actual "task" string from the path argument.
    $key = backdrop_substr($item['path'], 13);

    // Denormalize and translate the contextual link.
    _menu_translate($item, $args, TRUE);
    if (!$item['access']) {
      continue;
    }

    // All contextual links are keyed by the actual "task" path argument,
    // prefixed with the name of the implementing module.
    $links['paragraphs-' . $key] = $item;
  }

  return $links;
}

/**
 * Implements hook_contextual_links_view_alter().
 *
 * Since there is no root path for the separate form for editing a paragraph,
 * contextual links need building in a custom fashion.
 *
 * @see contextual_pre_render_links()
 */
function paragraphs_contextual_links_view_alter(&$element, $items) {
  if (isset($element['#contextual_links']['paragraphs'])) {
    // Retrieve contextual menu links.
    $items += paragraphs_contextual_links($element['#contextual_links']['paragraphs'][1]);

    // Transform contextual links into parameters suitable for theme_link().
    $links = array();
    foreach ($items as $class => $item) {
      $class = backdrop_html_class($class);
      $links[$class] = array(
        'title' => $item['title'],
        'href' => $item['href'],
      );
      // @todo theme_links() should *really* use the same parameters as l().
      $item['localized_options'] += array('query' => array());
      $item['localized_options']['query'] += backdrop_get_destination();
      $links[$class] += $item['localized_options'];
    }
    $element['#links'] = $links;
  }
}

/**
 * Implements hook_admin_paths().
 */
function paragraphs_admin_paths() {
  $paths = array(
    'paragraphs/*' => FALSE,
  );

  return $paths;
}

/**
 * Get Paragraphs' router items.
 *
 * @param string $base
 *   The base URL of the menu router item.
 *
 * @return mixed
 *   Returns the result of a db_query on the menu_router table.
 */
function paragraphs_get_router_items($base) {
  // Performance: We only query available tasks once per request.
  return db_select('menu_router', 'm')
    ->fields('m')
    ->condition('tab_root', db_like($base) . '%', 'LIKE')
    ->condition('context', MENU_CONTEXT_NONE, '<>')
    ->condition('context', MENU_CONTEXT_PAGE, '<>')
    ->orderBy('weight')
    ->orderBy('title')
    ->execute()
    ->fetchAllAssoc('path', PDO::FETCH_ASSOC);
}

/**
 * Implements hook_autoload_info().
 */
function paragraphs_autoload_info() {
  return array(
    'ParagraphsItemEntity' => 'ParagraphsItemEntity.inc',
    'ParagraphsItemMetadataController' => 'ParagraphsItemMetadataController.inc',
    'ParagraphsItemEntityController' => 'ParagraphsItemEntityController.inc',
    'MigrateDestinationParagraphsItem' => 'migrate/destinations/MigrateDestinationParagraphsItem.inc',
    'ParagraphsMigrateParagraphsFieldHandler' => 'migrate/fields/ParagraphsMigrateParagraphsFieldHandler.inc',
    'paragraphs_handler_relationship' => 'views/paragraphs_handler_relationship.inc',
  );
}
