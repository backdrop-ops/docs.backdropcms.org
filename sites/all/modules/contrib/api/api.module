<?php

/**
 * @file
 * Generates and displays API documentation pages.
 *
 * This is an implementation of a subset of the Doxygen documentation generator
 * specification, tuned to produce output that best benefits the Drupal Codex
 * base. It is designed to assume the code it documents follows Drupal coding
 * conventions, and supports documentation blocks in formats described on
 * http://drupal.org/node/1354
 */

/**
 * Regular expression for matching file names with one or more extensions.
 */
define('API_RE_FILENAME', '([a-zA-Z0-9_-]+(?:\.[a-zA-Z0-9_-]+)+)');

/**
 * Regular expression for matching PHP functions and methods in text.
 *
 * These are patterns like ClassName::methodName(), or just function_name().
 * Possibly with namespaces. Doesn't include the ().
 */
define('API_RE_FUNCTION_IN_TEXT', '\\\\*[a-zA-Z_\x7f-\xff][\\\\a-zA-Z0-9_\x7f-\xff:]*');

/**
 * Regular expression for matching group/topic names.
 */
define('API_RE_GROUP_NAME', '[a-zA-Z_0-9\.\-]+');

/**
 * Regular expression for matching characters interior to function names.
 */
define('API_RE_FUNCTION_CHARACTERS', '[a-zA-Z0-9_\x7f-\xff]+');

/**
 * Regular expression for aggressively matching class names in text.
 *
 * Although class names can technically be just like function names, we
 * only want to match class names if they include a capital letter, so as
 * not to be too overly aggressive. Possibly can include namespaces.
 */
define('API_RE_CLASS_NAME_TEXT', '\\\\*[\\\\a-zA-Z0-9_\x7f-\xff]*[A-Z][\\\\a-zA-Z0-9_\x7f-\xff]*');

/**
 * Regular expression for less-aggressively matching class names in text.
 *
 * Matches class names that are namespaced, because we know these are not just
 * plain text words.
 */
define('API_RE_DEFINITE_CLASS_NAME_TEXT', '[\\\\a-zA-Z0-9_\x7f-\xff]*[\\\\][\\\\a-zA-Z0-9_\x7f-\xff]*');

/**
 * Regular expression for starting inline \@tags.
 */
define('API_RE_TAG_START', '(?<!\\\)@');

/**
 * Regular expression for word boundary start for API linking.
 */
define('API_RE_WORD_BOUNDARY_START', '(?<=\s|^|\(|@)');

/**
 * Regular expression for word boundary end for API linking.
 */
define('API_RE_WORD_BOUNDARY_END', '(?=$|[\s.,:;?!)])');

/**
 * File path separator.
 */
define('API_FILEPATH_SEPARATOR', '/');

/**
 * Namespace separator.
 */
define('API_NAMESPACE_SEPARATOR', '\\');

/**
 * File path separator replacement.
 */
define('API_FILEPATH_SEPARATOR_REPLACEMENT', '!');

/**
 * File path separator replacement for API v 1.3.
 */
define('API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT', '--');

/**
 * Implements hook_help().
 */
function api_help($path, $arg) {
  switch ($path) {
    case 'admin/help#api':
      return t('
<p>This is an implementation of a subset of the Doxygen documentation generator specification, tuned to produce output that best benefits the Drupal code base. It is designed to assume the code it documents follows Drupal coding conventions, and supports documentation blocks in formats described on !doxygen_link.</p>

<h3>Set up</h3>

<p>Visit the !api_settings_page to configure the module. You must have the relevant Drupal code base on the same machine as the site hosting the API module. Set up Projects and Branches to index your Drupal code base.</p>

<p>Indexing of PHP functions is also supported, by setting up a PHP Reference Branch. If the site has internet access, then the default settings should work fine. For local development environments that have a PHP manual installed, you can edit the link path to point to the appropriate location.</p>

<p>The module indexes code branches during cron runs, so make sure the site has cron functionality set up properly.</p>
', array('!api_settings_page' => l(t('API settings page'), 'admin/config/development/api'), '!doxygen_link' => l('http://drupal.org/node/1354', 'http://drupal.org/node/1354')));

    case 'admin/config/development/api':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('File parse queue: parses PHP and other files for display.') . '</li>' .
        '<li>' . t('Branch update queue: scans branches for files that have been updated or removed, and adds jobs to the file parse and node cleanup queues.') . '</li>' .
        '<li>' . t('Node cleanup queue: deletes nodes for removed files.') . '</li>' .
        '<li>' . t('Reset the file parse queue: remove existing jobs and mark files as not queued for parsing. Next time each branch is scanned, files will be re-added to the queue as needed.') . '</li>' .
        '</ul>';

    case 'admin/config/development/api/projects':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('Project: A module, theme, Drupal Core, or other group of files that the API module is parsing.') . '</li>' .
        '<li>' . t('Project type: Normally "core", "module", "theme", or "library". The type "core" is special: core project functions are given priority when turning function, class, and other names into links in code listings.') . '</li>' .
        '</ul>';

    case 'admin/config/development/api/branches':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('Project: A module, theme, Drupal Core, or other group of files that the API module is parsing. Set up on the Projects tab.') . '</li>' .
        '<li>' . t('Branch: Within a Project, a particular version of the files (6.x-1.x, 7.x, 7.x-1.3, etc.).') . '</li>' .
        '<li>' . t('Core compatibility: usually 7.x, 6.x, etc. Branches with matching core compatibility are used to make cross-project links, and the default project and core compatibility (set on the Overview tab) determines the default branch.') . '</li>' .
        '<li>' . t('Reparse: Force a parse of every file in the branch, starting next time the branch is updated.') . '</li>' .
        '<li>' . t('Update: Force a scan of the file directories in the branch for updated and removed files. This normally happens during cron runs after a minimum time (set on branch edit page) has passed.') . '</li>' .
        '</ul>';

    case 'admin/config/development/api/php_branches':
      return '<h3>' . t('Definitions:') . '</h3><ul>' .
        '<li>' . t('PHP reference branch: Queries an external PHP web site, such as php.net, for its function list, in order to make links to these functions.') . '</li>' .
        '<li>' . t('API reference branch: Queries an external web site running the API module, such as api.drupal.org, in order to make links to Drupal API classes, functions, etc.') . '</li>' .
        '<li>' . t('Update: Force a scan of the selected branch. This normally happens during cron runs after a minimum time (set on branch edit page) has passed.') . '</li>' .
        '</ul>';
  }
}

/**
 * Returns a list of all defined branches.
 *
 * @param bool $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return array
 *   Array of branch objects, in order by branch weight.
 */
function api_get_branches($_reset = FALSE) {
  static $branches;

  if (!isset($branches) || $_reset) {
    $query = db_select('api_branch', 'b')
      ->fields('b');
    $query->leftJoin('api_project', 'p', 'b.project = p.project_name');
    $result = $query
      ->fields('p', array('project_title', 'project_type'))
      ->orderBy('weight', 'ASC')
      ->execute();
    $branches = array();
    foreach ($result as $branch) {
      api_unpack_branch_data($branch);
      $branches[$branch->branch_id] = $branch;
    }
  }

  return $branches;
}

/**
 * Returns a branch object, given a branch ID number.
 *
 * @param int $id
 *   Branch ID number.
 *
 * @return object|null
 *   Branch object for the given branch ID. If $id is not set, the default
 *   branch is returned. If the requested branch does not exist, NULL.
 */
function api_get_branch_by_id($id = NULL) {
  $branches = api_get_branches();
  if (!isset($id)) {
    $id = variable_get('api_default_branch', NULL);
  }
  if (isset($id) && isset($branches[$id])) {
    return $branches[$id];
  }

  return NULL;
}

/**
 * Returns the list of currently-used branch names across all projects.
 *
 * @param bool $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return array
 *   Array of branch names in use.
 */
function api_get_branch_names($_reset = FALSE) {
  static $branch_names;

  if (!isset($branch_names) || $_reset) {
    $result = db_select('api_branch', 'b')
      ->fields('b', array('branch_name'))
      ->execute()
      ->fetchCol();
    $branch_names = drupal_map_assoc($result);
  }

  return $branch_names;
}

/**
 * Returns a list of all defined reference branches.
 *
 * @param bool $_reset
 *   If set to TRUE, the cached return value is reset.
 *
 * @return array
 *   Array of reference branch objects, in order by title.
 */
function api_get_php_branches($_reset = FALSE) {
  static $branches;

  if (!isset($branches) || $_reset) {
    $result = db_select('api_php_branch', 'b')
      ->fields('b')
      ->orderBy('title')
      ->execute();
    $branches = array();
    foreach ($result as $branch) {
      api_unpack_branch_data($branch);
      $branches[$branch->branch_id] = $branch;
    }
  }

  return $branches;
}

/**
 * Implements hook_menu().
 */
function api_menu() {
  $items = array();

  // Admin overview.
  $items['admin/config/development/api'] = array(
    'title' => 'API reference',
    'description' => 'Configure projects and branches for API documentation.',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_page_admin_overview',
    'file' => 'api.admin.inc',
  );

  $items['admin/config/development/api/overview'] = array(
    'title' => 'Overview',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );

  $items['admin/config/development/api/reset_queue'] = array(
    'title' => 'Reset parse queue',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_reset_queue_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // Projects admin.
  $items['admin/config/development/api/projects'] = array(
    'title' => 'Projects',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_project_list',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/config/development/api/projects/list'] = array(
    'title' => 'List',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/development/api/projects/new'] = array(
    'title' => 'New project',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_project_edit_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/development/api/projects/%'] = array(
    'title' => 'Edit project',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_project_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/projects/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_project_delete_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // Branches admin.
  $items['admin/config/development/api/branches'] = array(
    'title' => 'Branches',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_branch_list',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  $items['admin/config/development/api/branches/list'] = array(
    'title' => 'List',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/development/api/branches/new'] = array(
    'title' => 'New branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%'] = array(
    'title' => 'Edit branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%/reparse'] = array(
    'title' => 'Reparse branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_reparse',
    'page arguments' => array(5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%/update'] = array(
    'title' => 'Update branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_update',
    'page arguments' => array('branch', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/branches/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_branch_delete_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // PHP reference branches admin.
  $items['admin/config/development/api/php_branches'] = array(
    'title' => 'Reference branches',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_php_branch_list',
    'file' => 'api.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 15,
  );

  $items['admin/config/development/api/php_branches/new'] = array(
    'title' => 'New PHP reference branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_php_branch_edit_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/php_branches/new_api'] = array(
    'title' => 'New API reference branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_api_branch_edit_form'),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/php_branches/%'] = array(
    'title' => 'Edit PHP reference branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_php_branch_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/api_branches/%'] = array(
    'title' => 'Edit API reference branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_api_branch_edit_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/php_branches/%/delete'] = array(
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('api_php_branch_delete_form', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/development/api/php_branches/%/update'] = array(
    'title' => 'Update branch',
    'access callback' => 'user_access',
    'access arguments' => array('administer API reference'),
    'page callback' => 'api_admin_update',
    'page arguments' => array('php_branch', 5),
    'file' => 'api.admin.inc',
    'type' => MENU_CALLBACK,
  );

  // Comment admin.
  if (module_exists('comment')) {
    $items['admin/config/development/api/comments'] = array(
      'title' => 'Comment settings',
      'access arguments' => array('administer API reference'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_comments_settings_form'),
      'file' => 'api.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 20,
    );

    $items['admin/config/development/api/comments/apply'] = array(
      'title' => 'Apply comment settings',
      'access arguments' => array('administer API reference'),
      'page callback' => 'api_apply_comment_settings',
      'file' => 'api.admin.inc',
      'type' => MENU_CALLBACK,
    );
  }

  // Projects autocomplete callback. This is always available.
  $items['api/project/autocomplete'] = array(
    'page callback' => 'api_project_autocomplete',
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  // The rest of the menu items require there to be at least one branch.
  $branches = api_get_branches();
  if (!count($branches)) {
    return $items;
  }

  $default_branch = api_get_branch_by_id();
  $projects = _api_make_menu_projects();
  if (!count($projects) || !isset($default_branch->project)) {
    return $items;
  }

  // Legacy search URLs.
  $items['api/search'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/' . $default_branch->branch_name . '/search', array(), '302'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  foreach ($branches as $branch) {
    if (!isset($items['api/search/' . $branch->branch_name . '/%'])) {
      $items['api/search/' . $branch->branch_name . '/%'] = array(
        'page callback' => 'api_legacy_search_redirect',
        'page arguments' => array($branch, 3),
        'access arguments' => array('access API reference'),
        'type' => MENU_CALLBACK,
        'file' => 'legacy.inc',
      );
    }
  }

  // Special URL to use for a redirect to search on 404.
  $items['apis'] = array(
    'title' => 'API search',
    'page callback' => 'api_search_redirect',
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // OpenSearch metadata callback.
  $items['api/opensearch/%/%'] = array(
    'page callback' => 'api_opensearch',
    'page arguments' => array(2, 3),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // OpenSearch suggestions callback.
  $items['api/suggest/%/%/%menu_tail'] = array(
    'page callback' => 'api_suggest',
    'page arguments' => array(2, 3, 4),
    'load arguments' => array('%map', '%index'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Search autocomplete callback.
  $items['api/search/autocomplete'] = array(
    'page callback' => 'api_search_autocomplete',
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
  );

  // Function dumps for IDEs and code editors.
  $items['api/function_dump/%'] = array(
    'page callback' => 'api_page_function_dump',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Project list.
  $items['api/projects'] = array(
    'title' => 'Projects',
    'page callback' => 'api_page_projects',
    'access arguments' => array('access API reference'),
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'api.pages.inc',
  );

  // File pages.
  $items['api/%/%api_filename'] = array(
    'title' => 'File',
    'load arguments' => array(1, 3), // project, branch
    'page callback' => 'api_page_file',
    'page arguments' => array(2),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%api_filename/theme_invokes'] = array(
    'title' => 'File',
    'load arguments' => array(1, 4), // project, branch
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(2, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  // Individual item pages.
  $items['api/%/%/function/%api_item'] = array(
    'title' => 'Function',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/function/calls/%api_item'] = array(
    'title' => 'Function calls',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'calls'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/implementations/%api_item'] = array(
    'title' => 'Function implementations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'implementations'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/references/%api_item'] = array(
    'title' => 'Function references',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'references'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/invokes/%api_item'] = array(
    'title' => 'Hook invocations',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/theme_invokes/%api_item'] = array(
    'title' => 'Theme invokes',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'theme_invokes'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/function/overrides/%api_item'] = array(
    'title' => 'Function calls',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'overrides'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/%/constant/%api_item'] = array(
    'title' => 'Constant',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'constant'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/global/%api_item'] = array(
    'title' => 'Global',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'global'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/property/%api_item'] = array(
    'title' => 'Property',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_simple_item',
    'page arguments' => array(4, 'property'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/class/%api_item'] = array(
    'title' => 'Class',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/class/hierarchy/%api_item'] = array(
    'title' => 'Class hierarchy',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class_hierarchy',
    'page arguments' => array(5),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/class/uses/%api_item'] = array(
    'title' => 'Class uses',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'uses'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/interface/%api_item'] = array(
    'title' => 'Interface',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/interface/hierarchy/%api_item'] = array(
    'title' => 'Class hierarchy',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_class_hierarchy',
    'page arguments' => array(5),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/interface/uses/%api_item'] = array(
    'title' => 'Class uses',
    'load arguments' => array(1, 6, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_function_calls',
    'page arguments' => array(5, 'uses'),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );
  $items['api/%/%/group/%api_item'] = array(
    'title' => 'Group',
    'load arguments' => array(1, 5, 2, 3), // project, branch, filename, type
    'page callback' => 'api_page_group',
    'page arguments' => array(4),
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  $items['api/%/namespace/%/%'] = array(
    'title' => 'Namespace',
    'page callback' => 'api_page_namespace',
    'page arguments' => array(1, 4, 3), // project, branch, namespace
    'access arguments' => array('access API reference'),
    'type' => MENU_CALLBACK,
    'file' => 'api.pages.inc',
  );

  foreach ($branches as $branch) {
    $is_default = !is_null($default_branch) && ($branch->branch_name === $projects[$branch->project]['use branch']);

    // Main branch page
    if ($is_default) {
      $items['api/' . $branch->project] = array(
        'title' => 'API reference',
        'page callback' => 'api_page_branch',
        'page arguments' => array($branch),
        'access arguments' => array('access API reference'),
        'type' => $branch->branch_id === $default_branch->branch_id ? MENU_NORMAL_ITEM : MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_branch',
      'page arguments' => array($branch),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    // Branch search page.
    $items['api/' . $branch->project . '/' . $branch->branch_name . '/search'] = array(
      'title' => $branch->title,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('api_search_form', $branch),
      'access arguments' => array('access API reference'),
      'type' => MENU_NORMAL_ITEM,
    );

    $items['api/' . $branch->project . '/' . $branch->branch_name . '/search/%menu_tail'] = array(
      'title' => $branch->title,
      'page callback' => 'api_search_listing',
      'page arguments' => array($branch, 4),
      'load arguments' => array('%map', '%index'),
      'access arguments' => array('access API reference'),
      'type' => MENU_NORMAL_ITEM,
      'file' => 'api.pages.inc',
    );

    // Listings within a branch.

    if ($is_default) {
      $items['api/' . $branch->project . '/functions'] = array(
        'title' => 'Functions',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'function'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/functions/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'function'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/constants'] = array(
        'title' => 'Constants',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'constant'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/constants/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'constant'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/globals'] = array(
        'title' => 'Globals',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'global'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/globals/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'global'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/files'] = array(
        'title' => 'Files',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'file'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/files/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'file'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/classes'] = array(
        'title' => 'Classes and interfaces',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'class'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/classes/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'class'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/groups'] = array(
        'title' => 'Topics',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'group'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/groups/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'group'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/namespaces'] = array(
        'title' => 'Namespaces',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'namespace'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/namespaces/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'namespace'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    if ($is_default) {
      $items['api/' . $branch->project . '/deprecated'] = array(
        'title' => 'Deprecated',
        'page callback' => 'api_page_listing',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch, 'deprecated'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'api.pages.inc',
      );
    }
    $items['api/' . $branch->project . '/deprecated/' . $branch->branch_name] = array(
      'title' => $branch->title,
      'page callback' => 'api_page_listing',
      'page arguments' => array($branch, 'deprecated'),
      'access arguments' => array('access API reference'),
      'type' => $is_default ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
      'file' => 'api.pages.inc',
    );

    // Dump of all documentation items in the branch.
    if ($is_default) {
      $items['api/' . $branch->project . '/full_list'] = array(
        'title' => 'Full list of items',
        'page callback' => 'api_dump_full_list',
        'access arguments' => array('access API reference'),
        'page arguments' => array($branch),
        'type' => MENU_CALLBACK,
        'file' => 'api.pages.inc',
      );
    }

    $items['api/' . $branch->project . '/full_list/' . $branch->branch_name] = array(
      'title' => 'Full list of items',
      'page callback' => 'api_dump_full_list',
      'access arguments' => array('access API reference'),
      'page arguments' => array($branch),
      'type' => MENU_CALLBACK,
      'file' => 'api.pages.inc',
    );
  }

  // Redirect 1.0 file links.
  $items['api/file/%menu_tail'] = array(
    'page callback' => 'api_file_redirect',
    'page arguments' => array(2),
    'load arguments' => array('%map', '%index'),
    'access callback' => TRUE,
    'file' => 'legacy.inc',
  );

  // Redirect 1.1 links.
  // Objects
  $items['api/function/%api_legacy_1_2_object'] = array(
    'load arguments' => array('function', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/function/%api_legacy_1_2_object/%'] =  $items['api/function/%api_legacy_1_2_object'];


  $items['api/constant/%api_legacy_1_2_object'] = array(
    'load arguments' => array('constant', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constant/%api_legacy_1_2_object/%'] = $items['api/constant/%api_legacy_1_2_object'];


  $items['api/global/%api_legacy_1_2_object'] = array(
    'load arguments' => array('global', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/global/%api_legacy_1_2_object/%'] = $items['api/global/%api_legacy_1_2_object'];


  $items['api/group/%api_legacy_1_2_object'] = array(
    'load arguments' => array('group', 3),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/group/%api_legacy_1_2_object/%'] = $items['api/group/%api_legacy_1_2_object'];

  // Default listings
  $items['api/functions'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/functions', array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/files', array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/constants', array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/globals', array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project . '/groups', array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array('api/' . $default_branch->project, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // Branch listings
  $items['api/functions/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('functions'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/files/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('files'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/constants/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('constants'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/globals/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('globals'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/groups/%api_legacy_1_2_listing'] = array(
    'load arguments' => array('groups'),
    'page callback' => 'drupal_goto',
    'page arguments' => array(2, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['api/%api_legacy_1_2_listing'] = array(
    'page callback' => 'drupal_goto',
    'page arguments' => array(1, array(), '302'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Returns a list of projects with their default branches, for use in menus.
 *
 * Basically, we need to define a default branch for each project: the first
 * "preferred" branch with the correct core compatibility.
 *
 * @return array
 *   Associative array whose keys are project names, and whose values are
 *   each an associative array with elements:
 *   - max branch: Name of the highest-numbered (or technically, latest in
 *     alphabetical order) branch found for each project.
 *   - use branch: Name of the branch to use as the default for this project,
 *     which must be marked "preferred" and have the default core
 *     compatibility. However if none is found, the "max" branch is used.
 */
function _api_make_menu_projects() {
  $branches = api_get_branches();
  if (!count($branches)) {
    return array();
  }

  $compatibility = variable_get('api_default_core_compatibility', '7.x');
  $projects = array();

  foreach ($branches as $branch) {
    if (!isset($projects[$branch->project])) {
      $projects[$branch->project] = array(
        'max branch' => $branch->branch_name,
        'use branch' => NULL,
      );
    }
    else {
      $projects[$branch->project]['max branch'] = max($projects[$branch->project]['max branch'], $branch->branch_name);
    }

    if ($branch->core_compatibility === $compatibility && $branch->preferred) {
      $projects[$branch->project]['use branch'] = $branch->branch_name;
    }
  }

  foreach (array_keys($projects) as $project) {
    if (is_null($projects[$project]['use branch'])) {
      $projects[$project]['use branch'] = $projects[$project]['max branch'];
    }
  }

  return $projects;
}

/**
 * Finds objects for old URLs and returns the new URL.
 *
 * @param $object_name
 *   Name of the object to find the URL of.
 * @param $object_type
 *   Type of object ('function', 'constant', etc.).
 * @param $branch_name
 *   Name of the branch to find the object in (across projects).
 *
 * @return
 *   First matching URL for this combination of object name, type, and branch
 *   name, or FALSE if none is found (so it can be used as a hook_menu() magic
 *   argument loader function).
 */
function api_legacy_1_2_object_load($object_name, $object_type, $branch_name) {
  foreach (api_get_branches_by_name($branch_name) as $branch) {
    $object = api_object_load($object_name, $branch, $object_type);
    if (isset($object)) {
      return api_url($object);
    }
  }

  return FALSE;
}

/**
 * Returns the current path to listing pages accessed with old URLs.
 *
 * @param $branch_name
 *   Name of the branch to redirect.
 * @param $type
 *   Type of listing page ('functions', etc.), or NULL for the home page.
 *
 * @return
 *   URL to redirect this listing to, in the default project.
 */
function api_legacy_1_2_listing_load($branch_name, $type = NULL) {
  $branch = api_get_branch_by_id();
  if (empty($branch_name)) {
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }
  if (isset($type)) {
    return 'api/' . $branch->project . '/' . $type . '/' . $branch_name;
  }
  else {
    return 'api/' . $branch->project . '/' . $branch_name;
  }
}

/**
 * Finds all branches matching a branch name, across projects.
 *
 * @param string $branch_name
 *   Branch name to match. If empty, defaults to the default branch.
 *
 * @return array
 *   Array of all branch objects with this name.
 */
function api_get_branches_by_name($branch_name) {
  $return = array();
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      return array();
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->branch_name === $branch_name) {
      $return[] = $branch;
    }
  }

  return $return;
}

/**
 * Loads a branch, given a project and branch name.
 *
 * @param string $project
 *   The project name matching {api_branch}.project.
 * @param string $branch_name
 *   The branch name matching {api_branch}.branch_name. If not set, uses the
 *   default branch name.
 *
 * @return object|null
 *   Object representing the branch, or NULL if there is no match.
 */
function api_get_branch_by_name($project, $branch_name) {
  if (empty($branch_name)) {
    $branch = api_get_branch_by_id();
    if (isset($branch)) {
      $branch_name = $branch->branch_name;
    }
    else {
      $branch_name = '';
    }
  }

  foreach (api_get_branches() as $branch) {
    if ($branch->project === $project && $branch->branch_name === $branch_name) {
      return $branch;
    }
  }

  return NULL;
}

/**
 * Loads an API object for the menu router.
 *
 * Menu object load callback for %api_item in menu paths.
 *
 * @param $object_name
 *   The object name matching {api_documentation}.object_name.
 * @param $project
 *   The project name matching {api_branch}.project.
 * @param $branch_name
 *   The branch name matching {api_branch}.branch_name.
 * @param $file_name
 *   The name of the file the object is in, with API_FILEPATH_SEPARATOR for path
 *   separators. We convert all API_FILEPATH_SEPARATOR_REPLACEMENTs back to
 *   API_FILEPATH_SEPARATORs to maintain the original file path information.
 *   (When a URL is created for a documentation object, all
 *   API_FILEPATH_SEPARATORs in the original file path are replaced with
 *   API_FILEPATH_SEPARATOR_REPLACEMENTs so that API_FILEPATH_SEPARATORs won't
 *   be interpreted as part the of URL.
 * @param $type
 *   API item type; one of function, constant, global, property, class,
 *   interface, or group.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_item_load($object_name, $project, $branch_name, $file_name, $type) {
  // Check type
  if (!in_array($type, array('function', 'constant', 'global', 'property', 'class', 'interface', 'group'))) {
    return FALSE;
  }

  // Load branch
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  // Load object
  $back_to_orig_filename = str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name);
  $doc_object = api_object_load($object_name, $branch, $type, $back_to_orig_filename);

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load($object_name, $branch, $type, str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name) );
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Implements hook_cron_queue_info().
 */
function api_cron_queue_info() {
  // Note that the order here is the order the queues will be invoked.
  return array(
    'api_branch_update' => array(
      'worker callback' => 'api_queue_update_branch',
      'time' => 30,
    ),
    'api_parse' => array(
      'worker callback' => 'api_queue_parse_file',
      'time' => 60,
    ),
    'api_node_delete' => array(
      'worker callback' => 'api_queue_node_delete',
      'time' => 15,
    ),
  );
}

/**
 * Loads an API file object.
 *
 * Menu object load callback for %api_filename in menu paths.
 *
 * API v 1.3 replaced all '/'s in the file path with '--' for the URL generated
 * for the file. We need to handle a URL with '--' (=
 * API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) and redirected it to the current,
 * correct URL.  We now convert all '/'s (= API_FILEPATH_SEPARATOR) to
 * API_FILEPATH_SEPARATOR_REPLACEMENT when a URL is created for a documentatio
 * object. Here we need to go back to the original filename and path.
 *
 * @param $file_name
 *   Name of the file to load.
 * @param $project
 *   Name of the project the file is in.
 * @param $branch_name
 *   Name of the branch the file is in.
 *
 * @return
 *   Loaded documentation object, or FALSE if not found (returning FALSE will
 *   cause the Drupal menu system to recognize it's a 404 error).
 */
function api_filename_load($file_name, $project, $branch_name) {
  $branch = api_get_branch_by_name($project, $branch_name);
  if (is_null($branch)) {
    return FALSE;
  }

  $doc_object = api_object_load(str_replace(API_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');

  if (empty($doc_object) && (strpos($file_name, API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT) !== FALSE)) {
    // May be an API 1.3 style path. See if we can load a valid object with the
    // old replacement pattern.
    $doc_object = api_object_load(str_replace(API_v1_3_FILEPATH_SEPARATOR_REPLACEMENT, API_FILEPATH_SEPARATOR, $file_name), $branch, 'file');
    // If we could, redirect to the current URL.
    if (!empty($doc_object)) {
      drupal_goto(api_url($doc_object));
    }
  }

  if (empty($doc_object)) {
    return FALSE;
  }

  return $doc_object;
}

/**
 * Loads a documentation object.
 *
 * @param $object_name_or_did
 *   The string object name or integer documentation ID to load.
 * @param $branch
 *   Branch object. Ignored if $object_name_or_did is an integer.
 * @param $object_type
 *   A string type, or array of strings: class, interface, function, etc.
 *   Can be omitted if $object_name_or_did is an integer.
 * @param $file_name
 *   Name of the file the object is in (if needed). Ignored if
 *   $object_name_or_did is an integer.
 *
 * @return
 *   Object with information about the matching documentation, or NULL if it
 *   does not exist.
 */
function api_object_load($object_name_or_did, $branch = NULL, $object_type = '', $file_name = NULL) {
  static $cache;

  if (!is_array($object_type)) {
    $object_type = array($object_type);
  }

  if (is_int($object_name_or_did)) {
    $key = $object_name_or_did;
  }
  else {
    $key = $object_name_or_did . ':' . implode('-', $object_type) . ':' . $branch->branch_id . ':' . $file_name;
  }

  // See if we have this cached.
  if (isset($cache[$key])) {
    return $cache[$key];
  }

  // We don't have a cached value. Prepare the query.

  // Set up the basic query.
  $query = db_select('api_documentation', 'ad');
  $ao = $query->leftJoin('api_overrides', 'ao', 'ao.did = ad.did');
  $query
    ->fields('ad')
    ->fields($ao, array('documented_did', 'overrides_did'));

  if (is_int($object_name_or_did)) {
    // Quick query on just the documentation ID.
    $query->condition('ad.did', $object_name_or_did);
  }
  else {
    $query
      ->condition('ad.object_type', $object_type)
      ->condition('ad.branch_id', $branch->branch_id)
      ->condition('ad.object_name', $object_name_or_did);
    if (!is_null($file_name)) {
      $query->condition('ad.file_name', $file_name);
    }
  }

  // Set up extra fields, depending on the object type.
  if (in_array('function', $object_type)) {
    $afunc = $query->leftJoin('api_function', 'afunc', 'afunc.did = ad.did');
    $query->fields($afunc, array('signature', 'parameters', 'return_value'));
  }
  elseif (in_array('file', $object_type)) {
    $afile = $query->leftJoin('api_file', 'afile', 'afile.did = ad.did');
    $query->fields($afile, array('modified', 'queued'));
  }

  // Set up field for the file's doc ID.
  $query->leftJoin('api_documentation', 'adfile', "adfile.file_name = ad.file_name AND adfile.object_type = 'file' AND adfile.branch_id = ad.branch_id");
  $query->addField('adfile', 'did', 'file_did');

  // Execute the query, and store in cache if it's successful.
  $query = $query->range(0, 1);
  $result = $query->execute();
  $result_object = NULL;
  foreach ($result as $result_object) {
    // Grab documentation from documented parent.
    if (!empty($result_object->documented_did) && $result_object->documented_did !== $result_object->did) {
      $documented_object = api_object_load((int) $result_object->documented_did, $branch, $object_type);
      if (isset($documented_object)) {
        foreach (array('documentation', 'parameters', 'return_value', 'see', 'deprecated', 'throws', 'var') as $member) {
          $result_object->$member = $documented_object->$member;
        }
      }
    }
    // Store in the cache.
    $cache[$key] = $result_object;
    return $result_object;
  }

  return NULL;
}

/**
 * Loads namespace and use information for a file.
 *
 * @param int $file_did
 *   Documentation ID of the file.
 *
 * @return
 *   Associative array with elements:
 *   - namespace: Name of the namespace for this file (could be '').
 *   - use_alias: Associative array of use statement class aliases. Keys are
 *     the alias names, and values are the fully namespaced class names.
 */
function api_get_namespace_info($file_did = NULL) {
  static $cache = array();

  $ret = array('namespace' => '', 'use_alias' => array());

  if (!isset($file_did) || !$file_did) {
    return $ret;
  }

  if (isset($cache[$file_did])) {
    return $cache[$file_did];
  }

  $values = db_select('api_namespace', 'n')
    ->condition('did', $file_did)
    ->condition('class_name', '', '<>')
    ->fields('n', array('object_type', 'class_alias', 'class_name'))
    ->execute();
  foreach ($values as $info) {
    // Start namespaces with backslash.
    $name = $info->class_name;
    if (drupal_substr($name, 0, 1) != '\\') {
      $name = '\\' . $name;
    }

    if ($info->object_type == 'namespace') {
      $ret['namespace'] = $name;
    }
    else {
      $ret['use_alias'][$info->class_alias] = $name;
    }
  }

  $cache[$file_did] = $ret;

  return $ret;
}

/**
 * Figures out the full class name of a class, with namespaces.
 *
 * @param string $name
 *   The name as it appears, which could include a namespace, and might or
 *   might not start with a backslash if it does.
 * @param string $namespace
 *   The namespace for the file the name appears in.
 * @param array $use_aliases
 *   Associative array of alias name to full name for use statements in the
 *   file the name appears in.
 *
 * @return string
 *   Fully-qualified name of the class, starting with a backslash.
 */
function api_full_classname($name, $namespace = array(), $use_aliases = array()) {

  // Break off the class name from the rest.
  $classname = $name;
  $suffix = '';

  $pos = strpos($name, '::');
  if ($pos === FALSE) {
    $pos = strpos($name, '->');
  }
  if ($pos !== FALSE) {
    $classname = substr($name, 0, $pos);
    $suffix = substr($name, $pos);
  }

  if (in_array($classname, array('self', 'static', 'parent', 'this'))) {
    // Skip these keywords.
    return $name;
  }

  // See if there is an alias for this class name, or if we should prepend
  // the file's namespace.
  if (isset($use_aliases[$classname])) {
    // This class was aliased.
    $classname = $use_aliases[$classname];
  }
  elseif (strpos($classname, '\\') === FALSE) {
    // There was no alias, and the classname did not have a namespace in it.
    $classname = $namespace . '\\' . $classname;
  }

  // Make sure to start with a backslash, no matter what.
  if (strpos($classname, '\\') !== 0) {
    $classname = '\\' . $classname;
  }

  return $classname . $suffix;
}

/**
 * Implements hook_permission().
 */
function api_permission() {
  return array(
    'access API reference' => array(
      'title' => t('Access API reference pages'),
    ),
    'administer API reference' => array(
      'title' => t('Administer API reference'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function api_theme() {
  return array(
    'api_defined' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-defined',
      'file' => 'api.theme.inc',
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_defined'),
    ),
    'api_functions' => array(
      'variables' => array(
        'functions' => array(),
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-functions',
    ),
    'api_function_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'signatures' => NULL,
        'documentation' => NULL,
        'parameters' => NULL,
        'return' => NULL,
        'related_topics' => NULL,
        'call_links' => array(),
        'code' => NULL,
        'see' => NULL,
        'deprecated' => NULL,
        'throws' => NULL,
        'class' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-function-page',
      'file' => 'api.theme.inc',
    ),
    'api_constant_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'deprecated' => NULL,
        'class' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-constant-page',
      'file' => 'api.theme.inc',
    ),
    'api_global_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'deprecated' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-global-page',
      'file' => 'api.theme.inc',
    ),
    'api_property_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'deprecated' => NULL,
        'var' => NULL,
        'class' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-property-page',
      'file' => 'api.theme.inc',
    ),
    'api_class_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'implements' => NULL,
        'hierarchy' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'related_topics' => NULL,
        'see' => NULL,
        'deprecated' => NULL,
        'call_links' => array(),
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-class-page',
      'file' => 'api.theme.inc',
    ),
    'api_file_page' => array(
      'variables' => array(
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'code' => NULL,
        'see' => NULL,
        'deprecated' => NULL,
        'related_topics' => NULL,
        'defined' => '',
        'call_links' => array(),
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-file-page',
      'file' => 'api.theme.inc',
    ),
    'api_group_page' => array(
      'variables' => array(
        'branch' => NULL,
        'object' => NULL,
        'documentation' => NULL,
        'objects' => NULL,
        'see' => NULL,
      ),
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_object_page'),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-group-page',
      'file' => 'api.theme.inc',
    ),
    'api_branch_default_page' => array(
      'variables' => array(
        'branch' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-branch-default-page',
    ),
    'api_function_reference_link' => array(
      'variables' => array(
        'type' => '',
        'count' => 0,
        'function' => (object) array(),
        'override_text' => '',
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'file' => 'api.theme.inc',
    ),
    'api_class_section' => array(
      'variables' => array(
        'class' => NULL,
        'branch' => NULL,
      ),
      'path' => drupal_get_path('module', 'api') . '/templates',
      'template' => 'api-class-section',
      'file' => 'api.theme.inc',
      'preprocess functions' => array('template_preprocess', 'api_preprocess_api_class_section'),
    ),
    'api_views_view_dl_list' => array(
      'variables' => array(
      ),
      'template' => 'api-views-view-dl-list',
      'path' => drupal_get_path('module', 'api') . '/templates',
      'file' => 'api.theme.inc',
      'preprocess functions' => array('template_preprocess', 'api_preprocess_views_view_dl_list'),
    ),
  );
}

/**
 * Saves or returns a string to use for the HTML page title.
 *
 * @param string $title
 *   If provided, stores this as the page title.
 *
 * @return string|null
 *   The previously-set page title, or NULL if it has not been set during
 *   this page load.
 */
function api_set_html_page_title($title = NULL) {
  static $page_title = NULL;

  if (isset($title)) {
    $page_title = $title;
  }

  return $page_title;
}

/**
 * Implements hook_preprocess_HOOK() for html.tpl.php.
 *
 * Sets the page title if it's an API module page and a title was set in
 * api_set_html_page_title().
 */
function api_preprocess_html(&$variables) {
  $title = api_set_html_page_title();
  if ($title) {
    $variables['head_title'] = $title;
  }
}

/**
 * Implements hook_init().
 *
 * Adds CSS and JavaScript for the search auto-complete. Adds OpenSearch
 * autodiscovery links. Redirects nodes of type 'api' to the correct URL.
 */
function api_init() {
  $branch = api_get_active_branch();

  // If we happen to be on an API node page, redirect.
  if (($node = menu_get_object('node')) && $node->type == 'api') {
    $result = db_select('api_documentation', 'd')
      ->fields('d', array('branch_id', 'object_type', 'file_name', 'object_name'))
      ->condition('did', $node->nid)
      ->range(0, 1)
      ->execute()
      ->fetchObject();
    drupal_goto(api_url($result));
  }

  // Add OpenSearch autodiscovery links.
  $weight = 100;
  foreach (api_get_branches() as $branch) {
    $title = t('Drupal API @branch', array('@branch' => $branch->title));
    $url = url('api/opensearch/' . $branch->project . '/' . $branch->branch_name, array('absolute' => TRUE));
    drupal_add_html_head(array(
        '#tag' => 'link',
        '#weight' => $weight,
        '#attributes' => array(
          'href' => $url,
          'title' => $title,
          'rel' => 'search',
          'type' => 'application/opensearchdescription+xml',
        ),
      ), $title);
    $weight++;
  }
}

/**
 * Implements hook_query_TAG_alter() for node_access queries.
 *
 * Excludes nodes of type 'api' from queries tagged 'node_access', unless the
 * 'api_ignore_node_access' tag is also present. Also skips this if we are on
 * the comment admin page.
 */
function api_query_node_access_alter($query) {
  // Skip this processing if the 'api_ignore_node_access' query tag has been
  // set. This allows building things like comment forms in Views.
  if ($query->hasTag('api_ignore_node_access')) {
    return;
  }

  // Skip this processing on the comment admin page.
  $arg = arg();
  if (count($arg) >= 3 && $arg[0] == 'admin' && $arg[1] == 'content' && $arg[2] == 'comment') {
    return;
  }

  // Find all instances of the 'node' table, and make sure they exclude API
  // nodes.
  $tables = $query->getTables();
  foreach ($tables as $alias => $table_info) {
    if (is_array($table_info) && isset($table_info['table']) && $table_info['table'] == 'node') {
      $or = db_or()
        ->isNull($alias . '.type')
        ->condition($alias . '.type', 'api', '<>');
      $query->condition($or);
    }
  }
}

/**
 * Implements hook_block_info().
 */
function api_block_info() {
  return array(
    'api-search' => array(
      'info' => t('API search'),
      // This needs to be non-cached as it's a form with a form
      // token in it, and they can't be stale.
      'cache' => DRUPAL_NO_CACHE,
    ),
    'navigation' => array(
      'info' => t('API navigation'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function api_block_view($delta) {
  $branch = api_get_active_branch();

  switch ($delta) {
    case 'api-search':
      if (user_access('access API reference') && !empty($branch)) {
        return array(
          'subject' => t('Search @branch', array('@branch' => $branch->title)),
          'content' => drupal_get_form('api_search_form', $branch),
        );
      }
      return;

    case 'navigation':
      if (user_access('access API reference') && !empty($branch)) {
        // Figure out if this is the default branch for this project, the same
        // way the menu system decides.

        $default_branch = api_get_branch_by_id();
        $projects = _api_make_menu_projects();
        $is_default = ($branch->branch_name === $projects[$branch->project]['use branch']);
        $suffix = ($is_default) ? '' : '/' . $branch->branch_name;

        $links = array();
        $links[] = l($branch->title, 'api/' . $branch->project . $suffix);
        $counts = api_listing_counts($branch);
        if ($counts['constants'] > 0) {
          $links[] = l(t('Constants'), 'api/' . $branch->project . '/constants' . $suffix);
        }
        if ($counts['classes'] > 0) {
          $links[] = l(t('Classes'), 'api/' . $branch->project . '/classes' . $suffix);
        }
        if ($counts['files'] > 0) {
          $links[] = l(t('Files'), 'api/' . $branch->project . '/files' . $suffix);
        }
        if ($counts['functions'] > 0) {
          $links[] = l(t('Functions'), 'api/' . $branch->project . '/functions' . $suffix);
        }
        if ($counts['globals'] > 0) {
          $links[] = l(t('Globals'), 'api/' . $branch->project . '/globals' . $suffix);
        }
        if ($counts['groups'] > 0) {
          $links[] = l(t('Topics'), 'api/' . $branch->project . '/groups' . $suffix);
        }
        if ($counts['namespaces'] > 0) {
          $links[] = l(t('Namespaces'), 'api/' . $branch->project . '/namespaces' . $suffix);
        }
        if ($counts['deprecated'] > 0) {
          $links[] = l(t('Deprecated'), 'api/' . $branch->project . '/deprecated' . $suffix);
        }

        return array(
          'subject' => t('API Navigation'),
          'content' => theme('item_list', array('items' => $links)),
        );
      }
      return;
  }
}

/**
 * Counts items by type for a branch.
 *
 * @param $branch
 *   Object representing the branch to count.
 *
 * @return
 *   Associative array where the keys are the type of listing ('functions',
 *   'classes', etc.) and the values are the count of how many there are in
 *   that listing for the given branch.
 */
function api_listing_counts($branch) {
  static $cached_counts = array();

  // Check the cache.
  $key = $branch->branch_name . $branch->branch_id;
  if (isset($cached_counts[$key])) {
    return $cached_counts[$key];
  }

  $return = array(
    'groups' => 0,
    'classes' => 0,
    'functions' => 0,
    'constants' => 0,
    'globals' => 0,
    'files' => 0,
    'namespaces' => 0,
    'deprecated' => 0,
  );

  // These queries mirror what is done in the views used by api_page_listing().
  $query = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('object_type', 'group')
    ->groupBy('branch_id');
  $query->addExpression('COUNT(*)', 'num');
  $return['groups'] = $query
    ->execute()
    ->fetchField();

  $query = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('namespace', '', '<>')
    ->groupBy('namespace');
  $query->addExpression('COUNT(*)', 'num');
  $return['namespaces'] = $query
    ->execute()
    ->fetchField();

  $query = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('object_type', array('class', 'interface'))
    ->condition('class_did', 0)
    ->groupBy('branch_id');
  $query->addExpression('COUNT(*)', 'num');
  $return['classes'] = $query
    ->execute()
    ->fetchField();

  $query = db_select('api_documentation', 'ad')
    ->condition('branch_id', $branch->branch_id)
    ->condition('deprecated', '', '<>')
    ->groupBy('branch_id');
  $query->addExpression('COUNT(*)', 'num');
  $return['deprecated'] = $query
    ->execute()
    ->fetchField();

  foreach (array('function', 'constant', 'global', 'file') as $type) {
    $query = db_select('api_documentation', 'ad')
      ->condition('branch_id', $branch->branch_id)
      ->condition('object_type', $type)
      ->condition('class_did', 0)
      ->groupBy('branch_id');
    $query->addExpression('COUNT(*)', 'num');
    $return[$type . 's'] = $query
      ->execute()
      ->fetchField();
  }

  $cached_counts[$key] = $return;
  return $return;
}

/**
 * Implements hook_filter_info().
 */
function api_filter_info() {
  return array(
    'api_filter' => array(
      'title' => t('API filter'),
      'description' => t('Add links to API objects, like theme() or theme.inc.'),
      'process callback' => 'api_filter_documentation_process',
      'tips callback' => 'api_filter_documentation_tips',
    ),
  );
}

/**
 * Implements hook_forms().
 *
 * Since the 'api' content type is hidden, do what comment_forms() does so
 * that the comment form will work.
 */
function api_forms() {
  $forms = array();
  $forms['comment_node_api_form']['callback'] = 'comment_form';
  return $forms;
}

/**
 * Constructs a link to an API object page.
 *
 * Constructs a URL for an object, replacing any API_FILEPATH_SEPARATOR in a
 * file path with API_FILEPATH_SEPARATOR_REPLACEMENT.
 *
 * @param $object
 *   An API object with object_type, object_name, branch_id, and file_name
 *   properties.
 * @param bool $file
 *   TRUE links to the objects containing file, FALSE links to the object
 *   itself.
 *
 * @return
 *   A URL string, or an empty string if there was a problem.
 */
function api_url($object, $file = FALSE) {
  $branch = api_get_branch_by_id($object->branch_id);
  if (!$branch) {
    return '';
  }

  if ($file) {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  elseif ($object->object_type === 'file') {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->object_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $branch->branch_name;
  }
  else {
    $replaced_string = str_replace(API_FILEPATH_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $object->file_name);
    return 'api/' . $branch->project . '/' . $replaced_string . '/' . $object->object_type . '/' . $object->object_name . '/' . $branch->branch_name;
  }
}

/**
 * Constructs a link to an API namespace page.
 *
 * Constructs a URL for a namespace, replacing any API_NAMESPACE_SEPARATOR in a
 * file path with API_FILEPATH_SEPARATOR_REPLACEMENT.
 *
 * @param $branch_id
 *   ID of the branch to make the link in.
 * @param $namespace
 *   Namespace to make the link for.
 *
 * @return
 *   A URL string, or an empty string if there was a problem.
 */
function api_namespace_url($branch_id, $namespace) {
  $branch = api_get_branch_by_id($branch_id);
  if (!$branch) {
    return '';
  }

  $replaced_string = str_replace(API_NAMESPACE_SEPARATOR, API_FILEPATH_SEPARATOR_REPLACEMENT, $namespace);
  return 'api/' . $branch->project . '/namespace/' . $replaced_string . '/' . $branch->branch_name;
}

/**
 * Saves an API branch.
 *
 * @param $branch
 *   A branch object.
 */
function api_save_branch($branch) {
  $branch->data = serialize($branch->data);
  // Update the queue valid timestamp for this branch so that old queue jobs
  // are invalid.
  $branch->queue_valid = time();
  // Update the last updated timestamp for this branch so that it will be
  // updated as soon as possible.
  $branch->last_updated = 0;

  if (empty($branch->branch_id)) {
    drupal_write_record('api_branch', $branch);
  }
  else {
    drupal_write_record('api_branch', $branch, 'branch_id');

    // We've just updated a files branch, so we need to mark all of the files
    // that were in the parse queue so that they are re-queued next time
    // we scan this branch for files.
    $query = db_select('api_file', 'f')
      ->fields('f', array('did'))
      ->condition('queued', 0, '<>');
    $query->leftJoin('api_documentation', 'd', 'f.did = d.did');
    $dids = $query->condition('d.branch_id', $branch->branch_id)
      ->execute()
      ->fetchCol();
    if (count($dids)) {
      db_update('api_file')
        ->condition('did', $dids)
        ->fields(array('queued' => 0))
        ->execute();
    }
  }

  api_reset_branches();
}

/**
 * Saves an API reference branch.
 *
 * @param $branch
 *   A reference branch object.
 */
function api_save_php_branch($branch) {
  $branch->data = serialize($branch->data);
  if (empty($branch->branch_id)) {
    drupal_write_record('api_php_branch', $branch);
  }
  else {
    drupal_write_record('api_php_branch', $branch, 'branch_id');
  }

  api_get_php_branches(TRUE);
}

/**
 * Saves an API project.
 *
 * @param $project
 *   A project to save.
 * @param $old_name
 *   If the project_name (primary key) field is changing, provide the previous
 *   name.
 */
function api_save_project($project, $old_name = '') {
  if (!strlen($old_name)) {
    $old_name = $project->project_name;
  }
  db_delete('api_project')
    ->condition('project_name', $old_name)
    ->execute();
  drupal_write_record('api_project', $project);

  if ($old_name != $project->project_name) {
    // Update existing branches to the new name.
    db_update('api_branch')
      ->condition('project', $old_name)
      ->fields(array('project' => $project->project_name))
      ->execute();
  }

  // See if our current default project is valid, and reset if not.
  $default = variable_get('api_default_project', '');
  if (!api_project_exists($default)) {
    variable_set('api_default_project', $project->project_name);
  }

  api_reset_branches();
}

/**
 * Checks to see if a project exists.
 *
 * @param project_name
 *   Name to check for.
 *
 * @return
 *   TRUE if the project exists, and FALSE if not.
 */
function api_project_exists($project_name) {
  $result = db_select('api_project', 'p')
    ->fields('p')
    ->condition('project_name', $project_name)
    ->execute()
    ->fetchObject();
  return isset($result->project_name) && $result->project_name == $project_name;
}

/**
 * Fixes up branches, after one is updated, added, or deleted.
 */
function api_reset_branches() {
  // Recalculate the default branch.
  $branches = api_get_branches(TRUE);
  $project = variable_get('api_default_project', '');
  $version = variable_get('api_default_core_compatibility', '');
  foreach ($branches as $branch) {
    if ($branch->project == $project && $branch->preferred && $branch->core_compatibility == $version) {
      variable_set('api_default_branch', $branch->branch_id);
      break;
    }
  }

  // Reset the branch lists.
  $branches = api_get_branches(TRUE);
  api_get_branch_names(TRUE);

  // Reweight all branches.
  usort($branches, 'api_branch_sort');
  $weight = 0;
  foreach ($branches as $branch) {
    $branch->weight = $weight;
    $weight += 1;
    drupal_write_record('api_branch', $branch, 'branch_id');
  }

  // Tell the menu system it needs rebuilding.
  variable_set('menu_rebuild_needed', TRUE);
}

/**
 * Sorts branches by project, version number, and branch name.
 *
 * Callback for usort() within api_reset_branches().
 */
function api_branch_sort($a, $b) {
  // Sort by project.
  if ($a->project != $b->project) {
    $default_project = variable_get('api_default_project', '');
    // If one of a or b is in the default project and the other isn't, that
    // one is preferred.
    if ($a->project == $default_project) {
      return -1;
    }
    if ($b->project == $default_project) {
      return 1;
    }

    // If one is core and the other isn't, that's preferred.
    if ($a->project_type == 'core' && $b->project_type != 'core') {
      return -1;
    }
    if ($a->project_type != 'core' && $b->project_type == 'core') {
      return 1;
    }

    // Otherwise, sort alphabetically.
    return strcasecmp($a->project, $b->project);
  }

  // Sort by core compatibility.
  if ($a->core_compatibility != $b->core_compatibility) {
    $default_version = variable_get('api_default_core_compatibility', '');

    // If one of a or b is in the default compatibility and the other isn't,
    // that one is preferred.
    if ($a->core_compatibility == $default_version) {
      return -1;
    }
    if ($b->core_compatibility == $default_version) {
      return 1;
    }

    // Otherwise, sort by version.
    $result = version_compare($a->core_compatibility, $b->core_compatibility);
  }

  // Sort by preferred (preferred over not preferred within one project and
  // core compatibility).
  if ($a->preferred && !$b->preferred) {
    return -1;
  }
  if ($b->preferred && !$a->preferred) {
    return 1;
  }

  // If all else fails, just do alphabetical.
  return strcasecmp($a->branch_name, $b->branch_name);
}

/**
 * Returns the currently active branch object.
 */
function api_get_active_branch() {
  static $branch;
  static $branch_set = FALSE;

  if (!$branch_set) {
    $branch_set = TRUE;
    $branches = api_get_branches();
    if (!count($branches)) {
      return NULL;
    }
    $branch_names = api_get_branch_names();
    $default_branch = variable_get('api_default_branch', NULL);

    // See if we are on an API page and get the active branch from that.
    // If we are not on an API page, calling menu_get_item() here could lead
    // to recursion, because it could be trying to load a text
    // field formatted with the API text filter, which calls this function,
    // and so on. So check arg() first.
    $arg = arg();
    if ($arg[0] != 'api') {
      // Just use the default branch, if it exists.
      if (!is_null($default_branch) && isset($branches[$default_branch])) {
        $branch = $branches[$default_branch];
      }
      return $branch;
    }

    // If we're on an API path, it should be safe to call menu_get_item().
    $item = menu_get_item();

    // See if we can extract a branch ID from a loaded component of $item.
    if (isset($item['page_arguments'][0]->branch_id)) {
      $branch = $branches[$item['page_arguments'][0]->branch_id];
    }
    elseif (isset($item['page_arguments'][0]->branch_name)) {
      $branch = $item['page_arguments'][0];
    }
    elseif ($item['path'] == 'api/%/namespace/%/%') {
      $project = $item['page_arguments'][0];
      $branch_name = $item['page_arguments'][1];
      $branch = api_get_branch_by_name($project, $branch_name);
    }
    elseif (strpos($item['path'], 'api/search') === 0 && isset($branch_names[$item['page_arguments'][0]])) {
      // This is a search page for a particular branch. Figure out what project
      // it corresponds to, using the default project if possible
      foreach ($branches as $possible_branch) {
        if ($possible_branch->project === $branches[$default_branch]->project && $possible_branch->branch_name === $item['page_arguments'][0]) {
          // Best case, this is a branch on the default project.
          $branch = $possible_branch;
          break;
        }
        elseif ($possible_branch->branch_name === $item['page_arguments'][0]) {
          // Second-best case, this at least matches. Keep looking.
          $branch = $possible_branch;
        }
      }
    }

    // If all else fails, use the default branch.
    if (!isset($branch)) {
      if (!is_null($default_branch) && isset($branches[$default_branch])) {
        $branch = $branches[$default_branch];
      }
      else {
        $branch = NULL;
      }
    }
  }

  return $branch;
}

/**
 * Form constructor for the API search form.
 *
 * @param $branch
 *   Object representing the branch to build the search form for.
 *
 * @see api_search_form_submit()
 */
function api_search_form($form, $form_state, $branch) {
  $form['#attributes']['class'] = 'api-search-form';
  $form['#branch'] = $branch;

  $form['search'] = array(
    '#title' => t('Function, file, or topic'),
    '#description' => t('Partial match search is supported'),
    '#type' => 'textfield',
    '#default_value' => '',
    '#required' => TRUE,
    '#attributes' => array('class' => array('api-search-keywords')),
    '#autocomplete_path' => 'api/search/autocomplete/' . $branch->branch_id,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );

  return $form;
}

/**
 * Form submission handler for api_search_form().
 */
function api_search_form_submit($form, &$form_state) {
  $branch = $form['#branch'];
  $form_state['redirect'] = 'api/' . $branch->project . '/' . $branch->branch_name . '/search/' . $form_state['values']['search'];
}

/**
 * Implements hook_cron().
 */
function api_cron() {
  // Do not do cron unless there is at least one branch, or if the
  // API admin page has been visited at least once.
  $doit = variable_get('api_do_cron', 0);
  if (!$doit) {
    $doit = (count(api_get_branches()) > 0);
  }

  if ($doit) {
    module_load_include('inc', 'api', 'parser');
    api_update_all_branches();
  }
}

/**
 * Turns function names into links in code.
 *
 * @param string $code
 *   PHP code to scan for function names.
 * @param object $branch
 *   Branch to make the links in.
 * @param int $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param int $class_did
 *   Documentation ID of the class the code is in (if any).
 *
 * @return string
 *   Code with function names formatted as links.
 *
 * @see api_link_documentation
 */
function api_link_code($code, $branch, $file_did = NULL, $class_did = NULL) {
  return _api_link_documentation($code, $branch, $file_did, $class_did, array('code hook name', 'code alter hook name', 'code theme hook name', 'code function', 'code member', 'code string', 'yaml reference', 'code global', 'code class'));
}

/**
 * Turns function names into links in documentation.
 *
 * @param string $documentation
 *   Documentation to scan for function names.
 * @param object $branch
 *   Branch to make the links in.
 * @param int $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param int $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param bool $aggressive_classes
 *   Try linking every word with a capital letter to a class or interface, if
 *   TRUE. Otherwise, just try to link words with backslashes in them.
 * @param bool $aggressive_topics
 *   For use in @see only, if TRUE try linking every paragraph as a topic name.
 *
 * @return string
 *   Documentation with function names formatted as links.
 *
 * @see api_link_code
 */
function api_link_documentation($documentation, $branch, $file_did = NULL, $class_did = NULL, $aggressive_classes = FALSE, $aggressive_topics = FALSE) {

  // First use the API filter to make links. To do that, we have to find a
  // branch to use if possible, and figure out what stages we need.

  if (is_null($branch)) {
    $branch = api_get_active_branch();
  }

  // Start with the code-related stages, for the @code sections. Follow with
  // the basic documentation stages.
  $stages = array('code hook name', 'code alter hook name', 'code theme hook name', 'code function', 'code member', 'code string', 'code global', 'code class', 'tags', 'link', 'function');

  if ($aggressive_topics) {
    // Look for topics before classes, constants, and files.
    $stages[] = 'topic';
  }
  $stages[] = 'file';
  $stages[] = 'constant';
  if ($aggressive_classes) {
    $stages[] = 'class';
  }
  else {
    $stages[] = 'definite class';
  }

  $documentation = _api_link_documentation($documentation, $branch, $file_did, $class_did, $stages);

  // Now remove escaping from \@.
  $documentation = preg_replace('!\\\@!', '@', $documentation);

  // Now use the standard Drupal URL filter to make links out of bare URLs in
  // the text.
  $filter = new stdClass();
  $filter->callback = '_filter_url';
  $filter->settings = array('filter_url_length' => 72);

  return _filter_url($documentation, $filter);
}

/**
 * Returns filter help ("tips") for the API text filter.
 */
function api_filter_documentation_tips($filter, $format, $long) {
  return t('Function names (and classes, constants, etc.) turn into links.');
}

/**
 * Filters text: turns documentation into links.
 *
 * This is the process callback for the API documentation filter. It turns
 * function names into links on output, using the currently active branch.
 * Other parameters are passed to this function, but they are not actually used.
 *
 * @param $text
 *   Text to be filtered.
 */
function api_filter_documentation_process($text) {

  // Try to get the current branch.
  $branch = api_get_active_branch();

  // If we are on an API module page, load the current menu router item and
  // see if we can extract an API class and file ID from it. If we are not on
  // an API module page, there is no point trying, and besides calling
  // menu_get_item() could lead to recursion if it is trying to load a text
  // field formatted with the API text filter (on a node for instance).
  $class_did = 0;
  $file_did = 0;
  $arg = arg();
  if ($arg[0] == 'api') {
    $item = menu_get_item();
    if (isset($item['load_functions'])) {
      foreach ($item['load_functions'] as $index => $function) {
        if ($function == 'api_item_load' && isset($item['map'][$index]) && is_object($item['map'][$index])) {
          $obj = $item['map'][$index];
          $class_did = $obj->class_did;
          $file_did = $obj->file_did;
          if (!$class_did && ($obj->object_type == 'class' || $obj->object_type == 'interface')) {
            $class_did = $obj->did;
          }
          break;
        }
      }
    }
  }

  return api_link_documentation($text, $branch, $file_did, $class_did, FALSE, FALSE);
}

/**
 * Makes links in documentation and code.
 *
 * Recursively calls itself to iterate through various stages. At each stage,
 * api_split() is called to find matches for a particular regular expression
 * pattern and process the matches via callback functions api_link_name(),
 * api_link_member_name(), and api_link_link().
 *
 * @param string $documentation
 *   PHP code or documentation to scan for text to link.
 * @param object $branch
 *   Branch to make the links in.
 * @param int $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param int $class_did
 *   Documentation ID of the class the documentation is in (if any).
 * @param array $stages
 *   Array of stages to process, which determines what type of links to make.
 *
 * @return string
 *   $documentation with text turned into links.
 */
function _api_link_documentation($documentation, $branch, $file_did = NULL, $class_did = NULL, $stages = array()) {
  // Pop off the next stage to run.
  $stage = array_shift($stages);

  // For this stage, figure out what regular expression pattern to use for
  // matching, what callback to call from api_split() for pattern matches,
  // and what arguments to pass to the callback function.
  $callback_match = 'api_link_name';
  $prepend = '';
  $append = '';
  $prepend_if_not_found = NULL;
  $use_php = FALSE;
  $type = '';
  $pattern = '';
  $continue_matching = FALSE;

  switch ($stage) {
    case 'tags':
      // Find HTML tags, not filtered.
      $callback_match = NULL;
      $pattern = '/(<[^>]+?' . '>)/';
      break;

    case 'link':
      // Find @link.
      $pattern = '/' . API_RE_TAG_START . 'link\s+(.*)\s+' . API_RE_TAG_START . 'endlink/U';
      $callback_match = 'api_link_link';
      break;

    case 'function':
      // Find function names, which are preceded by white space and followed by
      // '('.
      $append = '(';
      $pattern = '!' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_FUNCTION_IN_TEXT . ')\(!';
      $type = 'function';
      $use_php = TRUE;
      break;

    case 'code function':
      // Find function names in marked-up code.
      $pattern = '!<span class="php-function-or-constant">(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      $type = 'function_or_constant';
      $use_php = TRUE;
      break;

    case 'code class':
      // Find class names in marked-up code, as constructors.
      $pattern = '!<span class="php-function-or-constant">(' . API_RE_CLASS_NAME_TEXT . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      $type = 'class';
      break;

    case 'code global':
      // Find global variable names in marked-up code.
      $pattern = '!<span class="php-keyword">global</span> <span class="php-variable">\$(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!';
      $prepend = '<span class="php-keyword">global</span> <span class="php-variable">$';
      $append = '</span>';
      $type = 'global';
      break;

    case 'code string':
      // Find potential function names (callback strings) in marked-up code.
      // These are all strings that are legal function names, where the function
      // name is put into something like a hook_menu() page callback as a
      // string.
      $pattern = '!<span class="php-string">\'(' . DRUPAL_PHP_FUNCTION_PATTERN . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $type = 'function';
      break;

    case 'yaml reference':
      // Find potential function names (callback strings) in marked-up YAML
      // code. These are all strings that are legal function names, possibly
      // with namespaces and class names, possibly in quotes.
      $pattern = '!<span class="yaml-reference">(' . API_RE_FUNCTION_IN_TEXT . ')</span>!';
      $prepend = '<span class="php-function-or-constant">';
      $append = '</span>';
      $prepend_if_not_found = '';
      $append_if_not_found = '';
      $type = 'yaml_reference';
      break;

    case 'code hook name':
      // Find potential hook names in marked-up code. These are strings that
      // are legal function names, which were found in parsing to be inside
      // module_implements() and related functions.
      $pattern = '!<span class="php-string potential-hook">\'(' . API_RE_FUNCTION_CHARACTERS . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $type = 'hook';
      break;

    case 'code alter hook name':
      // Works like 'code hook name' above, but for alter hooks.
      $pattern = '!<span class="php-string potential-alter">\'(' . API_RE_FUNCTION_CHARACTERS . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $type = 'alter hook';
      break;

    case 'code theme hook name':
      // Works like 'code hook name' above, but for theme hooks.
      $pattern = '!<span class="php-string potential-theme">\'(' . DRUPAL_PHP_FUNCTION_PATTERN . ')\'</span>!';
      $prepend = '<span class="php-function-or-constant">\'';
      $append = '\'</span>';
      $prepend_if_not_found = '<span class="php-string">\'';
      $type = 'theme';
      break;

    case 'code member':
      // Works like 'code hook name' above, but for class members.
      $callback_match = 'api_link_member_name';
      $pattern = '!(<span class="php-function-or-constant [^"]+ member-of-[^"]+">' . DRUPAL_PHP_FUNCTION_PATTERN . '</span>)!';
      break;

    case 'file':
      // Find file names, which are an arbitrary number of strings joined with
      // '.'
      $pattern = '%' . API_RE_WORD_BOUNDARY_START . API_RE_FILENAME . API_RE_WORD_BOUNDARY_END . '%';
      $type = 'file';
      break;

    case 'constant':
      // Find constants, UPPERCASE_LETTERS_WITH_UNDERSCORES.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '([A-Z_]+)' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'constant';
      break;

    case 'class':
      // Find class names, which have a capital letter.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_CLASS_NAME_TEXT . ')' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'class';
      break;

    case 'definite class':
      // Find definite class names, which have a backslash.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_DEFINITE_CLASS_NAME_TEXT . ')' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'class';
      break;

    case 'topic':
      // Find topic/group names.
      $pattern = '/' . API_RE_WORD_BOUNDARY_START . '(' . API_RE_GROUP_NAME . ')' . API_RE_WORD_BOUNDARY_END . '/';
      $type = 'group';
      // Patterns that match topics might also match other objects.
      // keep looking for matches after running the linker.
      $continue_matching = TRUE;
      break;
  }

  // See if we have more stages to do. If so, set up to call this function
  // again; if not, we're done.
  if (count($stages) > 0) {
    $callback = '_api_link_documentation';
  }
  else {
    $callback = NULL;
  }

  return api_split($pattern, $documentation, $callback_match, array($branch, $prepend, $append, $file_did, $class_did, NULL, NULL, $use_php, $prepend_if_not_found, NULL, $type), $callback, array($branch, $file_did, $class_did, $stages), $continue_matching);
}

/**
 * Splits a string using a regular expression and processes using callbacks.
 *
 * @param $pattern
 *   The regular expression to match for splitting.
 * @param $subject
 *   The string to process.
 * @param $callback_match
 *   Function name to be called for text which matches $pattern. The first
 *   parameter will be the parenthesized expression in the pattern. Should
 *   return a string. NULL to pass the text through unchanged.
 * @param $callback_match_arguments
 *   An array of additional parameters for $callback_match.
 * @param $callback
 *   Function name to be called for text which does not match $pattern. The
 *   first parameter will be the text. Should return a string. NULL to pass the
 *   text through unchanged.
 * @param $callback_arguments
 *   An array of additional parameters for $callback.
 * @param $continue_matching
 *   If TRUE, call $callback again on the matched text if it is left unchanged
 *   by its callback.
 *
 * @return
 *   The original string, with both matched and unmatched portions filtered by
 *   the appropriate callbacks.
 */
function api_split($pattern, $subject, $callback_match = NULL, $callback_match_arguments = array(), $callback = NULL, $callback_arguments = array(), $continue_matching = FALSE) {
  $return = '';
  $matched = FALSE;
  foreach (preg_split($pattern . 'sm', $subject, -1, PREG_SPLIT_DELIM_CAPTURE) as $part) {
    if ($matched) {
      if (is_null($callback_match)) {
        $return .= $part;
      }
      else {
        $new_text = call_user_func_array($callback_match, array_merge(array($part), $callback_match_arguments));

        if ($new_text == $part && $continue_matching) {
          $new_text = call_user_func_array($callback, array_merge(array($part), $callback_arguments));
        }
        $return .= $new_text;
      }
    }
    else {
      if (is_null($callback)) {
        $return .= $part;
      }
      else {
        $return .= call_user_func_array($callback, array_merge(array($part), $callback_arguments));
      }
    }
    $matched = !$matched;
  }
  return $return;
}

/**
 * Links an object name to its documentation.
 *
 * Callback for api_split() in _api_link_documentation().
 *
 * Tries to find something to link to by looking for matches in the following
 * order:
 * - The passed-in branch.
 * - PHP reference branches, if $use_php is TRUE.
 * - The core branch with the same core compatibility.
 * - An API reference core branch with the same core compatibility.
 * - Any other branch with the same core compatibility.
 * - Any API reference branch with the same core compatibility.
 *
 * @param $name
 *   Object name to link to.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   (unused) Documentation ID of the class this is part of (if any).
 * @param $text
 *   Link text. If omitted, uses $name.
 * @param $is_link
 *   TRUE if this was inside a @link.
 * @param $use_php
 *   TRUE if links to functions found in PHP reference branches should be
 *   checked for and made; FALSE to skip this (normally only set to TRUE if
 *   this is a Drupal-specific thing like a hook name and thus looking for PHP
 *   reference functions would be pointless). API reference branches are always
 *   checked regardless of $use_php.
 * @param $prepend_if_not_found
 *   Text to prepend if object is not found (defaults to $prepend).
 * @param $append_if_not_found
 *   Text to append if object is not found (defaults to $append).
 * @param $type
 *   The type of information $name represents. Possible values:
 *   - '': (default) $name is a normal object name.
 *   - 'hook': $name is a hook name.
 *   - 'alter hook': $name is an alter hook name.
 *   - 'theme': $name is a theme hook name.
 *   - 'function': $name is specifically a function ('file', 'constant', etc.
 *     also are supported).
 *   - 'function_or_constant': $name is either a function, constant, or class.
 *   - 'group': $name is a group/topic identifier.
 *   - 'global': $name is a global variable.
 *   - 'yaml_reference': $name is the possibly namespaced name of a function or
 *     method, possibly in single or double quotes (in a YAML file).
 *
 * @return
 *   The text as a link to the object page.
 *
 * @see api_link_member_name()
 * @see api_link_link()
 */
function api_link_name($name, $branch, $prepend = '', $append = '', $file_did = NULL, $class_did = NULL, $text = NULL, $is_link = FALSE, $use_php = TRUE, $prepend_if_not_found = NULL, $append_if_not_found = NULL, $type = '') {

  if (is_null($text)) {
    $text = $name;
  }
  $name = trim($name);

  if ($type == 'yaml_reference') {
    // Trim off quotes and match as a function name.
    $name = trim($name, '"\'');
    $type = 'function';
  }

  // Get some information we will need in several places below.
  $nameinfo = api_get_namespace_info($file_did);
  $namespaced_name = api_full_classname($name, $nameinfo['namespace'], $nameinfo['use_alias']);
  $core_compatibility = ($branch) ? $branch->core_compatibility : variable_get('api_default_core_compatibility', '7.x');
  $api_branches = api_get_php_branches();

  // If we get here, we're looking to match some kind of documentation object.
  // Try to match within the passed-in branch.
  if ($branch) {
    $link = _api_make_match_link($name, $namespaced_name, $text, $type, $is_link, $branch);
    if ($link) {
      return $prepend . $link . $append;
    }
  }

  // If we get here, there wasn't a match. Try PHP functions.
  if ($use_php) {
    $link = _api_make_php_reference_link($name, $text);
    if ($link) {
      return $prepend . $link . $append;
    }
  }

  // If this is not a core branch, try matching in the core branch.
  $core_branch = api_find_core_branch($branch);

  if ($core_branch && $core_branch->branch_id != $branch->branch_id) {
    $link = _api_make_match_link($name, $namespaced_name, $text, $type, $is_link, $core_branch);
    if ($link) {
      return $prepend . $link . $append;
    }
  }

  if (!$core_branch) {
    // We do not have a core branch. See if there is an API reference core
    // branch to use, and if we can make a link there.
    $ids = array();
    foreach ($api_branches as $api_branch) {
      if ($api_branch->reference_type == 'api' &&
        ($api_branch->project_type == 'core') &&
        ($core_compatibility == $api_branch->core_compatibility)) {
        $ids[] = $api_branch->branch_id;
      }
    }

    if (count($ids)) {
      $link = _api_make_match_link($name, $namespaced_name, $text, $type, $is_link, NULL, '', $ids);
      if ($link) {
        return $prepend . $link . $append;
      }
    }
  }

  // Try to find a match at least within this same core compatibility, but
  // only if this was not a core branch.
  if (!$core_branch || $core_branch->branch_id != $branch->branch_id) {
    $link = _api_make_match_link($name, $namespaced_name, $text, $type, $is_link, NULL, $core_compatibility);
    if ($link) {
      return $prepend . $link . $append;
    }

    // Also try API reference branches with this core compatibility.
    $ids = array();
    foreach ($api_branches as $api_branch) {
      if ($api_branch->reference_type == 'api' &&
        ($core_compatibility == $api_branch->core_compatibility)) {
        $ids[] = $api_branch->branch_id;
      }
    }

    if (count($ids)) {
      $link = _api_make_match_link($name, $namespaced_name, $text, $type, $is_link, NULL, '', $ids);
      if ($link) {
        return $prepend . $link . $append;
      }
    }
  }

  // If we get here, there still wasn't a match, so return non-linked text.
  if (isset($prepend_if_not_found)) {
    $prepend = $prepend_if_not_found;
  }
  if (isset($append_if_not_found)) {
    $append = $append_if_not_found;
  }

  return $prepend . $text . $append;
}

/**
 * Finds matches for an object name in a branch and makes a link.
 *
 * Helper function for api_link_name().
 *
 * @param $name
 *   Name to match (text found in the code or documentation).
 * @param $namespaced_name
 *   Fully namespaced name to look for. Only used when $type is 'function',
 *   'function_or_constant', or 'class'. In these cases, the function tries to
 *   find matches of the namespaced name first, and if that fails, then it
 *   tries again with the plain name.
 * @param $text
 *   Text to put in the link.
 * @param $type
 *   Type of object to match (see api_link_name() for options).
 * @param $try_link
 *   If TRUE, try making links as if this is to a topic or file first.
 * @param $branch
 *   Object representing the branch to search. If NULL, use core compatibility
 *   instead.
 * @param $core_compatibility
 *   If $branch is NULL, search all branches with this core compatibility.
 * @param array $api_branch_ids
 *   If set, instead of looking in core branches, look in API reference branches
 *   that have an ID in this array.
 *
 * @return
 *   Link to either a single matching object or a search if multiple matches
 *   exist; if there are no matches, FALSE.
 */
function _api_make_match_link($name, $namespaced_name, $text, $type, $try_link = FALSE, $branch = NULL, $core_compatibility = '', $api_branch_ids = NULL) {

  if ($try_link) {
    // Before trying standard matches, see if this is a link to a group/topic.
    $link = _api_make_match_link($name, $namespaced_name, $text, 'group', FALSE, $branch, $core_compatibility, $api_branch_ids);
    if ($link) {
      return $link;
    }

    // Also see if it could be a file name being linked.
    $link = _api_make_match_link($name, $namespaced_name, $text, 'file', FALSE, $branch, $core_compatibility, $api_branch_ids);
    if ($link) {
      return $link;
    }
  }

  // Now do the standard linking tries.
  // Build a query to find the matches.
  if ($api_branch_ids) {
    $using_api_branch = TRUE;
    $query = db_select('api_external_documentation', 'ad')
      ->fields('ad')
      ->condition('ad.branch_id', $api_branch_ids);
  }
  else {
    $using_api_branch = FALSE;
    $query = db_select('api_documentation', 'ad')
      ->fields('ad', array('did', 'branch_id', 'object_name', 'title', 'object_type', 'summary', 'file_name'));
    $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
    $query->fields('b', array('branch_name', 'preferred', 'project'));
    if ($branch) {
      $query->condition('ad.branch_id', $branch->branch_id);
    }
    else {
      $query->condition('b.core_compatibility', $core_compatibility);
    }
  }

  // Deal with namespaces.
  if (in_array($type, array('function', 'function_or_constant', 'class'))) {
    $original_name = $name;
    $name = $namespaced_name;
    $match_name = $query->addField('ad', 'namespaced_name', 'match_name');
    $match_name_field = 'ad.namespaced_name';
    $search_name = $query->addField('ad', 'object_name', 'search_name');
    $search_name_field = 'ad.object_name';
  }
  elseif ($type != 'theme' && $type != 'file') {
    $match_name = $query->addField('ad', 'object_name', 'match_name');
    $match_name_field = 'ad.object_name';
    $search_name_field = NULL;
  }

  // Figure out what potential names we should match on.
  $potential_names = array($name);
  $prefer_shorter = FALSE;
  $prefer_earlier = FALSE;
  $search_term = NULL;

  if ($type == 'hook') {
    $potential_names = array(
      'hook_' . $name,
      'hook_entity_' . $name,
      'hook_entity_bundle_' . $name,
      'hook_field_' . $name,
      'field_default_' . $name,
      'hook_user_' . $name,
      'hook_node_' . $name,
    );
    $prefer_earlier = TRUE;
    $query->condition('ad.object_type', 'function');
    $search_term = '_' . $name;
  }
  elseif ($type == 'alter hook') {
    $potential_names = array('hook_' . $name . '_alter');
    $query->condition('ad.object_type', 'function');
  }
  elseif ($type == 'theme') {
    $potential_names = array();
    // Potential matches are the whole theme call, or with stripped off pieces
    // separated by __. And we look for template files preferably over
    // functions.
    $prefer_shorter = TRUE;
    $hook_elements = explode('__', $name);
    while (count($hook_elements) > 0) {
      $hook = implode('__', $hook_elements);
      $potential_names[] = str_replace('_', '-', $hook) . '.html.twig';
      $potential_names[] = str_replace('_', '-', $hook) . '.tpl.php';
      $potential_names[] = 'theme_' . $hook;
      array_pop($hook_elements);
    }
    // Because this needs to match theme files, match on object title (which is
    // the file base name).
    $query->condition('ad.object_type', array('file', 'function'));
    $match_name = $query->addField('ad', 'title', 'match_name');
    $match_name_field = 'ad.title';
  }
  elseif ($type == 'function') {
    $query->condition('ad.object_type', 'function');
  }
  elseif ($type == 'global') {
    $query->condition('ad.object_type', 'global');
  }
  elseif ($type == 'function_or_constant') {
    $query->condition('ad.object_type', array('function', 'constant', 'class', 'interface'));
  }
  elseif ($type == 'file') {
    // For files other than HTML type, the title is the basename of the file.
    // For HTML files, the title is taken from the HTML title element. So,
    // if we are matching in an API reference branch, try to match on the title
    // field, which is what we have. If we are matching in a regular branch,
    // join to the file table and match on the basename field.
    if ($using_api_branch) {
      $query->condition('ad.object_type', array('file'));
      $match_name = $query->addField('ad', 'title', 'match_name');
      $match_name_field = 'ad.title';
    }
    else {
      $query->leftJoin('api_file', 'af', 'ad.did = af.did');
      $match_name = $query->addField('af', 'basename', 'match_name');
      $match_name_field = 'af.basename';
    }
  }
  elseif ($type == 'constant') {
    $query->condition('ad.object_type', 'constant');
  }
  elseif ($type == 'class') {
    $query->condition('ad.object_type', array('class', 'interface'));
  }
  elseif ($type == 'group') {
    $query->condition('ad.object_type', 'group');
  }

  // Execute the query and make an array of matches, making sure to only
  // keep the highest-priority matches.
  $query->condition($match_name_field, $potential_names);
  $results = $query->execute();
  $best = array();
  $name_matched = '';
  $preferred_matched = 0;
  foreach ($results as $object) {
    // MySQL is not case-sensitive, so check the match for exact string.
    $matched = $object->match_name;
    if (!in_array($matched, $potential_names)) {
      continue;
    }

    // See if this matched name takes precedence over the previous one.
    $priority = _api_match_priority($matched, $name_matched, $prefer_shorter, $potential_names, $prefer_earlier);
    if ($priority == 0 && ($preferred_matched == $object->preferred)) {
      // Same priority: add to array.
      $best[] = $object;
    }
    elseif ($priority > 0 || ($object->preferred == 1 && $preferred_matched == 0)) {
      // Higher priority: start new array.
      $best = array($object);
      $name_matched = $matched;
      $preferred_matched = 1;
    }
  }

  if (!count($best) || ($type == 'group' && count($best) != 1)) {
    // If we didn't find anything, and we were trying to match within a
    // namespace, try to match without the namespace.
    if (in_array($type, array('function', 'function_or_constant', 'class')) && ('\\' . $original_name != $namespaced_name)) {
      return _api_make_match_link($original_name, '\\' . $original_name, $text, $type, FALSE, $branch, $core_compatibility, $api_branch_ids);
    }

    return FALSE;
  }

  // If we get here, we found one or more matches. If we found just one,
  // make a link and return.

  if (count($best) == 1) {
    $options = array(
      'attributes' => array(
        'title' => api_entity_decode($best[0]->summary),
        'class' => array('local'),
      ),
    );

    if ($using_api_branch) {
      $url = $best[0]->url;
      unset($options['attributes']['class']);
    }
    else {
      $url = api_url($best[0]);
    }

    if ($type == 'group' && $text == $name) {
      // Override with the group name if no link text was provided.
      $text = $best[0]->title;
    }
    elseif ($type == 'group') {
      // If this is a topic link and someone provided text, then it was
      // check_plained at parse time. Don't double-encode it!
      $options['html'] = TRUE;
    }

    return l($text, $url, $options);
  }

  // If we get here, we found multiple matches. So, return a link to a search
  // page.
  // @todo If we found multiple matches in the case of a multi-branch
  // search, we should probably go to a multi-branch search page, but this
  // does not exist yet. So just go to the first found branch.
  if (isset($search_name_field)) {
    $search_name = $best[0]->search_name;
  }
  else {
    $search_name = $best[0]->match_name;
  }

  $options = array(
    'attributes' => array(
      'title' => t('Multiple implementations exist.'),
      'class' => array('local'),
    ),
  );

  if ($using_api_branch) {
    $api_branches = api_get_php_branches();
    $api_branch = $api_branches[$best[0]->branch_id];
    $url = $api_branch->search_url;
    unset($options['attributes']['class']);
  }
  else {
    $url = 'api/' . $best[0]->project . '/' . $best[0]->branch_name . '/search/';
  }
  $url = $url . $search_name;

  return l($text, $url, $options);
}

/**
 * Finds matches for an object name in a PHP reference branch and makes a link.
 *
 * Helper function for api_link_name().
 *
 * @param $name
 *   Name to match (text found in the code or documentation).
 * @param $text
 *   Text to put in the link.
 *
 * @return
 *   Link to either a single matching object or a search if multiple matches
 *   exist; if there are no matches, FALSE.
 */
function _api_make_php_reference_link($name, $text) {
  $query = db_select('api_php_documentation', 'd')
    ->fields('d', array('object_name', 'documentation'));
  $b = $query->innerJoin('api_php_branch', 'b', "b.branch_id = d.branch_id");
  $query
    ->fields($b, array('data'))
    ->condition('d.object_type', 'function')
    ->condition('d.object_name', $name);
  $result = $query->execute();
  foreach ($result as $info) {
    // MySQL is not case-sensitive, so check the match for exact string.
    if ($info->object_name != $name) {
      continue;
    }

    $data = unserialize($info->data);
    $link = strtr($data['path'], array('!function' => $name));
    return l($text, $link, array('attributes' => array('title' => api_entity_decode($info->documentation), 'class' => array('php-manual'))));
  }

  // If we get here, we did not find a match in the PHP reference branches.
  return FALSE;
}

/**
 * Checks if the name found has higher or lower priority than previous match.
 *
 * Helper function for api_link_name(), to distinguish between theme functions
 * and theme templates.
 *
 * @param $current
 *   Current matched string.
 * @param $previous
 *   Previous matched string.
 * @param $prefer_shorter
 *   TRUE to prefer shorter names.
 * @param $potential_names
 *   Array of the potential names we were matching on.
 * @param $prefer_earlier
 *   TRUE to prefer earlier matches in list of potential names.
 *
 * @return
 *   1 if previous is empty or current has higher priority. 0 if they have
 *   the same priority. -1 if current has lower priority.
 */
function _api_match_priority($current, $previous, $prefer_shorter = TRUE, $potential_names, $prefer_earlier) {
  if (strlen($previous) == 0) {
    return 1;
  }
  if ($current == $previous) {
    return 0;
  }

  // Theme templates have higher priority than theme functions.
  $current_is_theme_function = (strpos($current, 'theme_') === 0);
  $current_is_theme_template = (strpos($current, '.tpl.php') === strlen($current) - 8);
  $previous_is_theme_function = (strpos($previous, 'theme_') === 0);
  $previous_is_theme_template = (strpos($previous, '.tpl.php') === strlen($previous) - 8);
  if ($current_is_theme_function && $previous_is_theme_template) {
    return -1;
  }
  if ($current_is_theme_template && $previous_is_theme_function) {
    return 1;
  }

  // Prefer the shorter item.
  if ($prefer_shorter && (strlen($current) < strlen($previous))) {
    return 1;
  }
  if ($prefer_shorter && (strlen($previous) < strlen($current))) {
    return -1;
  }

  // Prefer the earlier item.
  if ($prefer_earlier) {
    $current_index = array_search($current, $potential_names);
    $previous_index = array_search($previous, $potential_names);
    if ($current_index === FALSE) {
      return -1;
    }
    if ($previous_index === FALSE) {
      return 1;
    }
    if ($current_index < $previous_index) {
      return 1;
    }
    if ($current_index > $previous_index) {
      return -1;
    }
  }

  // All things being equal...
  return 0;
}

/**
 * Attempts to locate a core branch corresponding to the given branch.
 *
 * @param $branch
 *   Branch object to find a core branch for.
 *
 * @return
 *   Branch object for the core branch, if there is one. If not, FALSE.
 */
function api_find_core_branch($branch) {
  if (!$branch) {
    return FALSE;
  }

  $query = db_select('api_branch', 'b');
  $query->innerJoin('api_project', 'p', 'b.project = p.project_name');
  $query->condition('p.project_type', 'core');
  $query->condition('b.core_compatibility', $branch->core_compatibility);
  $query->fields('b');
  $query->fields('p', array('project_title', 'project_type'));
  $query->orderBy('b.weight', 'ASC');
  $result = $query->execute();
  // There shouldn't be more than one result, so assume that's the case and
  // return the first result found.
  foreach ($result as $branch) {
    api_unpack_branch_data($branch);
    return $branch;
  }

  return FALSE;
}

/**
 * Links text to an appropriate class member variable, constant, or function.
 *
 * Callback for api_split() in _api_link_documentation().
 *
 * Tries to find something to link to by looking for matches in the following
 * order:
 * - The passed-in branch.
 * - The core branch with the same core compatibility.
 * - An API reference core branch with the same core compatibility.
 * - Any other branch with the same core compatibility.
 * - Any API reference branch with the same core compatibility.
 *
 * @param $text
 *   Text matched by the regular expression.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Unused.
 * @param $append
 *   Unused.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class this is part of (if any).
 *
 * @see api_link_name()
 * @see api_link_link()
 */
function api_link_member_name($text, $branch, $prepend = '', $append = '', $file_did = NULL, $class_did = NULL) {

  // The pattern matched to get here contains the entire span with all of its
  // classes. Parse it out.
  $matches = array();
  preg_match('!<span class="php-function-or-constant ([^"]+) member-of-([^"]+)">(' . DRUPAL_PHP_FUNCTION_PATTERN . ')</span>!', $text, $matches);
  $name = $matches[3];
  $member_type = $matches[2];
  $object_type = $matches[1];

  $prepend = '<span class="php-function-or-constant">';
  $append = '</span>';

  // Get some information we will need in several places below.
  $nameinfo = api_get_namespace_info($file_did);
  $core_compatibility = ($branch) ? $branch->core_compatibility : variable_get('api_default_core_compatibility', '7.x');
  $api_branches = api_get_php_branches();

  // Convert parent references to the name of the parent class, which must be
  // in the api_reference_storage table for this branch.
  if ($member_type == 'parent') {
    if (!$class_did) {
      // We cannot do a parent reference if we do not know the class, so do
      // not make a link at all.
      return $prepend . $name . $append;
    }

    $parent_class = db_select('api_reference_storage', 'ars')
      ->condition('ars.from_did', $class_did)
      ->condition('ars.object_type', 'class')
      ->fields('ars', array('object_name'))
      ->execute()
      ->fetchField();
    if (!$parent_class) {
      return $prepend . $name . $append;
    }
    $member_type = 'class-' . $parent_class;
  }

  // Try matching in this branch.
  $link = _api_make_match_link_class_member($name, $nameinfo, $member_type, $object_type, $class_did, $file_did, $branch);
  if ($link) {
    return $prepend . $link . $append;
  }

  // If this is not a core branch, try matching in the core branch.
  $core_branch = api_find_core_branch($branch);
  if ($core_branch && $core_branch->branch_id != $branch->branch_id) {
    $link = _api_make_match_link_class_member($name, $nameinfo, $member_type, $object_type, $class_did, $file_did, $core_branch);
    if ($link) {
      return $prepend . $link . $append;
    }
  }

  if (!$core_branch) {
    // We do not have a core branch. See if there is an API reference core
    // branch to use, and if we can make a link there.
    $ids = array();
    foreach ($api_branches as $api_branch) {
      if ($api_branch->reference_type == 'api' &&
        ($api_branch->project_type == 'core') &&
        ($core_compatibility == $api_branch->core_compatibility)) {
        $ids[] = $api_branch->branch_id;
      }
    }

    if (count($ids)) {
      $link = _api_make_match_link_class_member($name, $nameinfo, $member_type, $object_type, $class_did, $file_did, NULL, '', $ids);
      if ($link) {
        return $prepend . $link . $append;
      }
    }
  }

  // Try to find a match at least within this same core compatibility, but
  // only if this was not a core branch.
  if (!$core_branch || $core_branch->branch_id != $branch->branch_id) {
    $link = _api_make_match_link_class_member($name, $nameinfo, $member_type, $object_type, $class_did, $file_did, NULL, $core_compatibility);
    if ($link) {
      return $prepend . $link . $append;
    }

    // Also try API reference branches with this core compatibility.
    $ids = array();
    foreach ($api_branches as $api_branch) {
      if ($api_branch->reference_type == 'api' &&
        ($core_compatibility == $api_branch->core_compatibility)) {
        $ids[] = $api_branch->branch_id;
      }
    }

    if (count($ids)) {
      $link = _api_make_match_link_class_member($name, $nameinfo, $member_type, $object_type, $class_did, $file_did, NULL, '', $ids);
      if ($link) {
        return $prepend . $link . $append;
      }
    }
  }

  // If we got here, we didn't have a match.
  return $prepend . $name . $append;
}

/**
 * Finds matches for a class member object name in a branch and makes a link.
 *
 * Helper function for api_link_member_name().
 *
 * @param $name
 *   Name to match (text found in the code).
 * @param $namespaced_info
 *   Namespace information for the file context
 *   (output of api_get_namespace_info()).
 * @param $member_type
 *   What type of reference to find: 'parent', 'self', 'variable', or
 *   'class-NAME'. This is set up in the parser.
 * @param $object_type
 *   'function' if this is a member function, etc.
 * @param $class_did
 *   Documentation ID of the class this is part of (if any).
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $branch
 *   Object representing the branch to search. If NULL, use core compatibility
 *   instead.
 * @param $core_compatibility
 *   If $branch is NULL, search all branches with this core compatibility.
 * @param array $api_branch_ids
 *   If set, instead of looking in core branches, look in API reference branches
 *   that have an ID in this array.
 *
 * @return
 *   Link to either a single matching object or a search if multiple matches
 *   exist; if there are no matches, FALSE.
 */
function _api_make_match_link_class_member($name, $namespace_info, $member_type, $object_type, $class_did = NULL, $file_did = NULL, $branch = NULL, $core_compatibility = '', $api_branch_ids = NULL) {

  // If we're looking for a specific class, see if it exists in this branch
  // or the reference branch.
  if (strpos($member_type, 'class-') === 0) {
    $class_name = substr($member_type, 6);
    $namespaced_name = api_full_classname($class_name, $namespace_info['namespace'], $namespace_info['use_alias']);
    if ($api_branch_ids) {
      // If we are looking in a reference branch, do the query to find this
      // exact member name $class_name::$name -- we cannot do anything very
      // fancy in that case, because we do not have the full member information.
      $result = db_select('api_external_documentation', 'ad')
        ->fields('ad')
        ->condition('ad.branch_id', $api_branch_ids)
        ->condition('object_type', $object_type)
        ->condition('namespaced_name', $namespaced_name . '::' . $name)
        ->execute()
        ->fetchObject();
      if ($result) {
        $url = $result->url;
        $options = array(
          'attributes' => array(
            'title' => api_entity_decode($result->summary),
          ),
        );
        return l($name, $result->url, $options);
      }
      else {
        return FALSE;
      }
    }
    // If we get here, we are looking in a real branch or compatible branches.
    // We want to find a matching class_did, and then convert this to being a
    // "self" reference on that class.
    $query = db_select('api_documentation', 'ad');
    $query->fields('ad', array('did'))
      ->condition('object_type', 'class')
      ->condition('namespaced_name', $namespaced_name);
    if (is_null($branch)) {
      $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
      $query->condition('b.core_compatibility', $core_compatibility);
    }
    else {
      $query->condition('ad.branch_id', $branch->branch_id);
    }
    $class_did = $query->execute()->fetchCol();
    $member_type = 'self';
    if (count($class_did) == 1) {
      $class_did = array_pop($class_did);
    }
    elseif (count($class_did) == 0) {
      // Class is not in this branch.
      return FALSE;
    }
  }

  $result = NULL;
  $using_api_branch = FALSE;

  if ($member_type == 'self') {
    // Type 'self' does not make sense for API reference branches.
    if ($api_branch_ids) {
      return FALSE;
    }

    // Looking for a member of a particular class, or one of several classes,
    // whose documentation ID we have already located. Use the {api_members}
    // table to find the right method, since it includes members inherited from
    // parent classes.
    $query = db_select('api_members', 'am');
    $ad = $query->innerJoin('api_documentation', 'ad', 'ad.did = am.did');
    $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
    $query
      ->fields('ad', array('branch_id', 'title', 'object_name', 'summary', 'object_type', 'file_name', 'did', 'member_name'))
      ->fields('b', array('branch_name', 'project'))
      ->condition('am.class_did', $class_did)
      ->condition('ad.member_name', $name);

    if ($object_type == 'function') {
      $query->condition('ad.object_type', 'function');
    }
    else {
      $query->condition('ad.object_type', 'function', '<>');
    }

    $result = $query->execute();
  }
  elseif ($member_type == 'variable') {
    // This was some kind of a variable like $foo->member(). So match any member
    // of any class in this branch or reference branch.
    if ($api_branch_ids) {
      // Looking in API reference branches.
      $using_api_branch = TRUE;
      $query = db_select('api_external_documentation', 'ad')
        ->fields('ad')
        ->condition('ad.branch_id', $api_branch_ids)
        ->condition('ad.member_name', $name);
    }
    else {
      // Looking in regular documentation branches.
      $query = db_select('api_documentation', 'ad');
      $query->innerJoin('api_branch', 'b', 'ad.branch_id = b.branch_id');
      $query
        ->fields('ad', array('branch_id', 'title', 'object_name', 'summary', 'object_type', 'file_name', 'did', 'member_name'))
        ->fields('b', array('branch_name', 'project'))
        ->condition('ad.member_name', $name);

      if (is_null($branch)) {
        $query->condition('b.core_compatibility', $core_compatibility);
      }
      else {
        $query->condition('ad.branch_id', $branch->branch_id);
      }
    }

    if ($object_type == 'function') {
      $query->condition('ad.object_type', 'function');
    }
    else {
      $query->condition('ad.object_type', 'function', '<>');
    }

    $result = $query->execute();
  }

  // See if we have one result, more than one result, or no results.
  $matches = array();
  if (isset($result)) {
    foreach ($result as $object) {
      // MySQL is not case-sensitive, so check the match for exact string.
      if ($object->member_name != $name) {
        continue;
      }
      $matches[] = $object;
    }
  }

  // No matches.
  if (!count($matches)) {
    return FALSE;
  }

  // If we found one match, return its URL as a link.
  if (count($matches) == 1) {
    $object = $matches[0];
    $options = array(
      'attributes' => array(
        'title' => api_entity_decode($object->summary),
        'class' => array('local'),
      ),
    );

    if ($using_api_branch) {
      $url = $object->url;
      unset($options['attributes']['class']);
    }
    else {
      $url = api_url($object);
    }
    return l($name, $url, $options);
  }

  // If we found multiple matches, make a search URL.
  // @todo If we found multiple matches in the case of a multi-branch
  // search, we should probably go to a multi-branch search page, but this
  // does not exist yet. So just go to the first found branch.
  $options = array(
    'attributes' => array(
      'title' => t('Multiple implementations exist.'),
      'class' => array('local'),
    ),
  );

  if ($using_api_branch) {
    $api_branches = api_get_php_branches();
    $api_branch = $api_branches[$best[0]->branch_id];
    $url = $api_branch->search_url . $name;
    unset($options['attributes']['class']);
  }
  else {
    $url = 'api/' . $matches[0]->project . '/' . $matches[0]->branch_name . '/search/' . $name;
  }

  return l($name, $url, $options);
}

/**
 * Decodes HTML entities.
 *
 * @param $text
 *   Text to decode.
 *
 * @return
 *   Text with all HTML entities decoded.
 */
function api_entity_decode($text) {
  $text = html_entity_decode($text);
  // html_entity_decode does not decode numeric entities, and there are
  // many cases of &#39; (quote) in here.
  $text = str_replace('&#039;', "'", $text);
  $text = str_replace('&#39;', "'", $text);
  return $text;
}

/**
 * Turns text into a link, using the first word as the object name.
 *
 * Callback for api_split() in _api_link_documentation().
 *
 * @param $name
 *   Text to link.
 * @param $branch
 *   Branch object indicating which branch to make the link in.
 * @param $prepend
 *   Text to prepend on the link.
 * @param $append
 *   Text to append on the link.
 * @param $file_did
 *   Documentation ID of the file the code is in (for namespace information).
 *   Can omit if namespaces are not relevant.
 * @param $class_did
 *   Documentation ID of the class the link is in (if any).
 *
 * @return
 *   The text as a link.
 *
 * @see api_link_member_name()
 * @see api_link_name()
 */
function api_link_link($name, $branch, $prepend = '', $append = '', $file_did = NULL, $class_did = NULL) {
  $words = preg_split('/\s+/', trim($name));
  $name = array_shift($words);
  return api_link_name($name, $branch, $prepend, $append, $file_did, $class_did, implode(' ', $words), TRUE);
}

/**
 * Flags a file, branch, or all branches, to be reparsed on the next cron run.
 *
 * @param $branch_or_file
 *   (optional) Identifier or ID number of the branch to reparse, or name of a
 *   single file to reparse. If omitted all branches will be reparsed. File
 *   names must include the path relative to the common path to the directories
 *   indexed by this branch.
 * @param $is_branch_name
 *   If passing in a branch name, set to TRUE so that if it happens to be an
 *   integer, it won't be considered to be a branch ID number by mistake.
 *   Otherwise, just leave this as the default FALSE.
 *
 * @return
 *   Number of files marked for reparsing.
 */
function api_mark_for_reparse($branch_or_file = NULL, $is_branch_name = FALSE) {
  $time_in_past = 52;

  // See if it's a request to reparse everything.
  if (empty($branch_or_file)) {
    return db_update('api_file')
      ->fields(array(
          'modified' => $time_in_past,
        ))
      ->execute();
  }

  // See if it's a request for a particular branch.
  if (!$is_branch_name && is_numeric($branch_or_file) && ($branch_or_file == intval($branch_or_file))) {
    $branch_id = $branch_or_file;
  }
  else {
    $branch_id = db_select('api_branch', 'b')
      ->fields('b', array('branch_id'))
      ->condition('branch_name', $branch_or_file)
      ->execute()
      ->fetchField();
  }

  if (!empty($branch_id)) {
    // Reparse a branch.
    // This is a query using a WHERE EXISTS, and there is no apparent way
    // to write it using the database API, so use ANSI syntax.
    $out = db_query("UPDATE {api_file} SET modified = :mod_time WHERE EXISTS ( SELECT * FROM {api_documentation} d WHERE d.branch_id = :branch_id AND d.object_type = 'file' AND d.did = {api_file}.did )", array(':mod_time' => $time_in_past, ':branch_id' => $branch_id));
    return $out->rowCount();
  }

  // If we get here, it's a request to reparse just one file. So find the file
  // ID, and then request its reparse.
  $did = db_select('api_documentation', 'd')
    ->fields('d', array('did'))
    ->condition('file_name', $branch_or_file)
    ->condition('object_type', 'file')
    ->execute()
    ->fetchField();

  if ($did) {
    $out = db_update('api_file')
      ->fields(array(
          'modified' => $time_in_past,
        ))
      ->condition('did', $did)
      ->execute();

    return $out;
  }

  return 0;
}

/**
 * Parses a queued file.
 *
 * @data
 *   Array of information about the file to be parsed.
 */
function api_queue_parse_file($data) {
  // Verify that the branch this job was saved with still exists.
  $branch = $data['branch'];
  $new_branch = api_get_branch_by_id($branch->branch_id);
  if (is_null($new_branch)) {
    watchdog('api', 'Invalid or deleted branch requested in API parse %project branch %branch %file', array('%branch' => $branch->branch_name, '%project' => $branch->project, '%file' => $data['file']));
    return;
  }
  $branch = $new_branch;

  // Verify that it's still a valid parse job (if the branch has been updated,
  // the parse job is not valid any more).
  $when_queued = (isset($data['timestamp']) ? $data['timestamp'] : 0);
  $valid_time = (isset($branch->queue_valid) ? $branch->queue_valid : 0);
  if ($when_queued < $valid_time) {
    watchdog('api', 'Skipped API parse %project branch %branch %file', array('%branch' => $branch->branch_name, '%project' => $branch->project, '%file' => $data['file']));
    return;
  }

  if ($when_queued >= $valid_time) {
    watchdog('api', 'API parse %project branch %branch %file', array('%branch' => $branch->branch_name, '%project' => $branch->project, '%file' => $data['file']));

    module_load_include('inc', 'api', 'parser');
    api_parse_file($data['parser'], $data['path'], $branch, $data['file']);
  }
}

/**
 * Checks a queued branch for updates.
 *
 * @data
 *   Array of information about the branch to be checked for updates.
 */
function api_queue_update_branch($data) {
  $type = $data['type'];
  $id = $data['branch_id'];
  if ($type == 'files') {
    $branch = api_get_branch_by_id($id);
    if (!is_null($branch)) {
      module_load_include('inc', 'api', 'parser');
      api_update_branch_files($branch);
      return;
    }
  }

  if ($type == 'php') {
    $branches = api_get_php_branches();
    if (isset($branches[$id])) {
      module_load_include('inc', 'api', 'parser');
      api_update_branch_php($branches[$id]);
      return;
    }
  }

  if ($type == 'api') {
    $branches = api_get_php_branches();
    if (isset($branches[$id])) {
      module_load_include('inc', 'api', 'parser');
      api_update_branch_api($branches[$id]);
      return;
    }
  }

  watchdog('api', 'Invalid or deleted branch requested in API update %type branch %branch', array('%type' => $type, '%branch' => $id), WATCHDOG_ERROR);
}

/**
 * Deletes obsolete nodes.
 *
 * @param $data
 *   Array with element 'nids' giving the IDs of the nodes to delete.
 */
function api_queue_node_delete($data) {
  watchdog('api', 'Removing a batch of %count obsolete nodes.', array('%count' => count($data['nids'])));
  node_delete_multiple($data['nids']);
}

/**
 * Resets the parse queue.
 *
 * Empties all parse jobs from the queue, and sets all files to "unqueued"
 * status.
 */
function api_reset_parse_queue() {
  $queue = DrupalQueue::get('api_parse');
  $queue->deleteQueue();

  db_update('api_file')
    ->fields(array(
        'queued' => 0,
      ))
    ->execute();
}

/**
 * Verifies that the required libraries are loaded.
 *
 * @param $watchdog
 *   TRUE to log an error if the library is not loaded (first time only).
 *
 * @return
 *   TRUE if OK, FALSE if parsing will not work.
 */
function api_libraries_loaded($watchdog = TRUE) {
  static $loaded = NULL;
  if (!is_null($loaded)) {
    return $loaded;
  }

  if (!gplib_version_check(FALSE)) {
    if ($watchdog) {
      watchdog('api', 'Grammar Parser library is not installed or version is incompatible.', array(), WATCHDOG_ERROR);
    }
    $loaded = FALSE;
    return FALSE;
  }

  $library = libraries_load('grammar_parser');
  $loaded = !empty($library['loaded']);
  if ($watchdog && !$loaded) {
    watchdog('api', 'Grammar Parser library is not loaded. Unable to parse files.', array(), WATCHDOG_ERROR);
  }

  if (!function_exists('mb_check_encoding')) {
    if ($watchdog) {
      watchdog('api', 'PHP multi-byte library is not installed.', array(), WATCHDOG_ERROR);
    }
    $loaded = FALSE;
    return FALSE;
  }

  return $loaded;
}

/**
 * Deletes a branch and all of its related documentation records.
 *
 * @param $branch_id
 *   The numeric ID of the branch to delete.
 * @param $finalize
 *   TRUE to redo the menus etc., FALSE to postpone (because other deletes
 *   are coming).
 */
function api_delete_branch($branch_id, $finalize = TRUE) {
  // Find out which documentation IDs need to be deleted.
  $dids = db_select('api_documentation', 'ad')
    ->fields('ad', array('did'))
    ->condition('branch_id', $branch_id)
    ->execute()
    ->fetchCol();

  // Fully delete these items, and the branch record.
  api_delete_items($dids);
  db_delete('api_branch')
    ->condition('branch_id', $branch_id)
    ->execute();

  if ($finalize) {
    api_reset_branches();
  }
}

/**
 * Deletes a reference branch and all of its related documentation records.
 *
 * @param $branch_id
 *   The numeric ID of the branch to delete.
 */
function api_delete_php_branch($branch_id) {
  // This could be a PHP or API reference branch. We could check the type,
  // but it is also fine to just delete from both documentation tables.
  db_delete('api_php_documentation')
    ->condition('branch_id', $branch_id)
    ->execute();
  db_delete('api_external_documentation')
    ->condition('branch_id', $branch_id)
    ->execute();
  db_delete('api_php_branch')
    ->condition('branch_id', $branch_id)
    ->execute();

  api_get_php_branches(TRUE);
}

/**
 * Deletes a project and all of its branches and documentation records.
 *
 * @param $project_name
 *   The name of the project to delete.
 */
function api_delete_project($project_name) {
  // Delete all of the branches.
  $branch_ids = db_select('api_branch', 'b')
    ->condition('project', $project_name)
    ->fields('b', array('branch_id'))
    ->execute()
    ->fetchCol();
  foreach ($branch_ids as $id) {
    api_delete_branch($id, FALSE);
  }

  // Delete the project itself.
  db_delete('api_project')
    ->condition('project_name', $project_name)
    ->execute();

  // Clean up.
  api_reset_branches();
}

/**
 * Completely deletes an array of documentation items.
 *
 * All records pertaining to the items, including nodes and comments, are
 * removed. If there are a lot, the batch API may be invoked, or a job may
 * be queued.
 *
 * @param $dids
 *   Array of the IDs of the items to delete.
 * @param $interactive
 *   TRUE if the batch_set() can be used if there are too many items to delete;
 *   FALSE if queue jobs need to be set up instead.
 *
 * @return
 *   TRUE if the items were deleted directly; FALSE if a batch or queue job
 *   was set up to delete some of them. In this case, in interactive mode, the
 *   calling function needs to ensure that the batch is processed. This is
 *   automatic if it's part of a form submission handler, but not otherwise.
 */
function api_delete_items($dids, $interactive = TRUE) {
  // Count the cumulative effect of calls in this page request.
  static $total_count = 0;

  // If there's nothing to do, return early.
  $count = count($dids);
  if ($count < 1) {
    return TRUE;
  }

  // Delete the items from api tables in batches of 100, because placeholder
  // queries can be a problem. This is fast though, so do not worry about
  // batching.
  $done = 0;
  while ($done < $count) {
    $this_batch = array_slice($dids, $done, 100);
    $done += 100;

    db_delete('api_documentation')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('class_did', $this_batch)
      )
      ->execute();
    db_delete('api_file')
      ->condition('did', $this_batch)
      ->execute();
    db_delete('api_namespace')
      ->condition('did', $this_batch)
      ->execute();
    db_delete('api_function')
      ->condition('did', $this_batch)
      ->execute();
    db_delete('api_members')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('class_did', $this_batch)
      )
      ->execute();
    db_delete('api_overrides')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('overrides_did', $this_batch)
        ->condition('documented_did', $this_batch)
      )
      ->execute();
    db_delete('api_reference_storage')
      ->condition('from_did', $this_batch)
      ->execute();
    db_delete('api_extends')
      ->condition(db_or()
        ->condition('did', $this_batch)
        ->condition('parent_did', $this_batch)
      )
      ->execute();
  }

  // The slow part is deleting the nodes. If there are more than 100 to delete
  // during this page request, do them using batch/queue jobs.
  // Also, if this particular call has only a few nodes, go ahead and delete,
  // to avoid having a ton of small jobs in the queue from a branch update.
  $total_count += $count;
  if ($total_count < 100 || $count < 5) {
    node_delete_multiple($dids);
    return TRUE;
  }

  // If we get here, we need to use batch/queue to delete the nodes.
  if ($interactive) {
    batch_set(array('operations' => array(array('_api_delete_nodes_batch', array($dids)))));
  }
  else {
    $queue = DrupalQueue::get('api_node_delete');
    $done = 0;
    while ($done < $count) {
      $this_batch = array_slice($dids, $done, 100);
      $done += 100;
      $queue->createItem(array('nids' => $this_batch));
    }
  }

  return FALSE;
}

/**
 * Deletes API nodes using the Batch API.
 *
 * @param $nids
 *   IDs of the nodes to delete.
 * @param $context
 *   Batch context.
 */
function _api_delete_nodes_batch($nids, &$context) {
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = count($nids);
    $context['sandbox']['nids'] = $nids;
  }

  $this_batch = array_slice($context['sandbox']['nids'], $context['sandbox']['progress'], 100);
  $context['sandbox']['progress'] += count($this_batch);
  node_delete_multiple($this_batch);
  $context['finished'] = min(1, $context['sandbox']['progress'] / $context['sandbox']['max']);
  if (!count($this_batch)) {
    // Just make sure we don't run an endless loop here.
    $context['finished'] = 1;
  }
}

/**
 * Performs AJAX autocomplete for projects.
 */
function api_project_autocomplete($string = '') {
  $matches = array();
  if ($string) {
    $result = db_select('api_project', 'p')
      ->fields('p', array('project_name'))
      ->condition('project_name', db_like($string) . '%', 'LIKE')
      ->orderBy('project_name')
      ->range(0, 10)
      ->execute()
      ->fetchCol();
    foreach ($result as $name) {
      $matches[$name] = check_plain($name);
    }
  }

  drupal_json_output($matches);
}

/**
 * Performs AJAX autocomplete for search.
 */
function api_search_autocomplete($branch_id, $string = '') {
  $matches = array();

  if ($string) {
    $result = db_select('api_documentation', 'ad')
      ->fields('ad', array('title'))
      ->condition('branch_id', $branch_id)
      ->condition('title', '%' . db_like($string) . '%', 'LIKE')
      ->orderBy('LENGTH(title)')
      ->range(0, 20)
      ->execute()
      ->fetchCol();
    foreach ($result as $name) {
      $matches[$name] = check_plain($name);
    }
  }

  drupal_json_output($matches);
}

/**
 * Implements hook_views_api().
 */
function api_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'api') . '/views',
    'template path' => drupal_get_path('module', 'api') . '/views/templates',
  );
}

/**
 * Unpacks and adds defaults to branch data.
 */
function api_unpack_branch_data($branch) {
  drupal_unpack($branch);
  if (!isset($branch->directories)) {
    $branch->directories = '';
  }
  if (!isset($branch->excluded_directories)) {
    $branch->excluded_directories = '';
  }
  if (!isset($branch->exclude_files_regexp)) {
    $branch->exclude_files_regexp = '';
  }
}

/**
 * Displays the output of a view, assumed to be a block display.
 *
 * @param $view_name
 *   Machine name of the view.
 * @param $display_name
 *   Machine name of the display within the view.
 * @param $args
 *   (optional) Array of arguments for the view display.
 *
 * @return
 *   String containing the view output. If the view was empty, an empty string.
 */
function api_display_view($view_name, $display_name, $args = array()) {
  $output = '';

  // Load the view.
  $view = views_get_view($view_name);

  if ($view) {
    // Override the URL so that exposed filters will work on blocks even without
    // AJAX.
    $view->override_url = current_path();
    $output = $view->preview($display_name, $args);
  }

  // Check for no content.
  if (!strlen(trim(strip_tags($output)))) {
    $output = '';
  }

  return $output;
}
